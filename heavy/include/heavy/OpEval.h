//===----- OpEval.h - Classes tree evaluation MLIR Operations ----*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
//  This file defines heavy::OpEval for tree evaluation of ops generated by OpGen
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_HEAVY_OP_EVAL_H
#define LLVM_HEAVY_OP_EVAL_H

#include "heavy/HeavyScheme.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/ScopedHashTable.h"
#include "llvm/Support/Casting.h"

namespace heavy {

class OpEval {
  heavy::Context& Context;

  using ValueMapTy = llvm::ScopedHashTable<mlir::Value, heavy::Value*>;
  using ValueMapScope = typename ValueMapTy::ScopeTy;

  ValueMapTy ValueMap;
  ValueMapScope ValueMapBaseScope;

  struct StackScope {
    heavy::Context& Context;
    ValueMapScope ScopeObj;
    heavy::StackFrame* Frame;

    StackScope(OpEval& E, llvm::ArrayRef<heavy::Value*> Args,
                          SourceLocation CallLoc)
      : Context(E.Context),
        ScopeObj(E.ValueMap),
        Frame(Context.EvalStack.push(Args, CallLoc))
    {
      llvm::errs() << "pushing StackScope\n";
    }

    ~StackScope() {
      llvm::errs() << "popping StackScope\n";
      Context.EvalStack.pop();
    }
  };

  void setValue(mlir::Value M, heavy::Value* H) {
    assert(M && "must set to a valid value");
    assert(H && "must set to a valid value");
    ValueMap.insert(M, H);
  }

  heavy::Value* getValue(mlir::Value M) {
    heavy::Value* V = ValueMap.lookup(M);
    if (!V) {
      return Context.CreateUndefined();
    }
    return V;
  }
  
  static heavy::SourceLocation getSourceLocation(mlir::Location Loc) {
    if (!Loc.isa<mlir::OpaqueLoc>()) return {};
    return heavy::SourceLocation(
      mlir::OpaqueLoc::getUnderlyingLocation<heavy::SourceLocationEncoding*>(
        Loc.cast<mlir::OpaqueLoc>()));
  }

public:
  OpEval(heavy::Context& C)
    : Context(C),
      ValueMap(),
      ValueMapBaseScope(ValueMap)
  { }

  heavy::Value* Visit(mlir::Value MVal) {
    if (MVal.isa<mlir::OpResult>()) {
      return Visit(MVal.getDefiningOp());
    } else {
      // BlockArgument
      llvm::errs() << "getting arg value M: " << (size_t) MVal.getAsOpaquePointer() << '\n';
      heavy::Value* V = ValueMap.lookup(MVal);
      assert(V && "argument must be in value table");
      assert(!isa<Undefined>(V) && "argument must not be undefined");
      return V;
    }
  }

  heavy::Value* Visit(mlir::Operation* Op) {
    // FIXME there has to be a better way to do this
    if (llvm::isa<ApplyOp>(Op))   return Visit(llvm::cast<ApplyOp>(Op));
    if (llvm::isa<BindingOp>(Op)) return Visit(llvm::cast<BindingOp>(Op));
    if (llvm::isa<BuiltinOp>(Op)) return Visit(llvm::cast<BuiltinOp>(Op));
    if (llvm::isa<SetOp>(Op))     return Visit(llvm::cast<SetOp>(Op));
    if (llvm::isa<LiteralOp>(Op)) return Visit(llvm::cast<LiteralOp>(Op));
    if (llvm::isa<LambdaOp>(Op))  return Visit(llvm::cast<LambdaOp>(Op));
    if (llvm::isa<UndefinedOp>(Op)) {
      return Context.CreateUndefined();
    }
    Op->dump();
    llvm_unreachable("Unknown Operation");
  }

  void LoadArgs(StackFrame* Frame, mlir::Block& Body) {
    // This associate values with BlockArguments
    // which should later be assigned to BingingOps (in code)

    // Note we are not setting the callee (which might end as a param)
    auto OpArgs = Body.getArguments();
    auto FrameArgs = Frame->getArgs();
    for (unsigned i = 0; i < OpArgs.size(); ++i) {
      llvm::errs() << "setting arg value M: " << (size_t) OpArgs[i].getAsOpaquePointer() << '\n';
      setValue(OpArgs[i], FrameArgs[i]);
    }
  }

  void EvaluateArgs(ApplyOp Op, llvm::SmallVectorImpl<heavy::Value*>& ArgResults) {
      ArgResults.clear();
      ArgResults.resize(Op.args().size() + 1);
      // We store args left to right, but we want to evaluate them
      // in reverse order to prevent accidental reliance on unspecified
      // behaviour
      for (int i = Op.args().size() - 1; i >= 0; --i) {
        ArgResults[i + 1] = Visit(Op.args()[i]);
      }
      heavy::Value* Callee = Visit(Op.fn());
      ArgResults[0] = Callee;
  }

  heavy::Value* Visit(ApplyOp OrigOp) {
    mlir::Operation* OpTail = OrigOp;
    llvm::SmallVector<heavy::Value*, 8> ArgResults;
    EvaluateArgs(OrigOp, ArgResults);
    while (true) {
      ApplyOp Op = cast<ApplyOp>(OpTail);
      heavy::SourceLocation CallLoc = getSourceLocation(Op.getLoc());

      StackScope SS(*this, ArgResults, CallLoc);
      heavy::StackFrame* Frame = SS.Frame;
      if (!Frame) return Context.CreateUndefined();

      heavy::Value* Callee = ArgResults[0];
      Frame->setCallee(Callee);

      switch (Callee->getKind()) {
        case Value::Kind::Lambda:
          llvm_unreachable("TODO");
          break;
        case Value::Kind::LambdaIr: {
          LambdaIr* L = cast<LambdaIr>(Callee);
          L->getOp().dump(); // FIXME looks like there is no actual body
          mlir::Block& Body = L->getBody();
          LoadArgs(Frame, Body);
          OpTail = VisitBodyUntilTail(Body);
          break;
        }
        case Value::Kind::Builtin: {
          Builtin* B = cast<Builtin>(Callee);
          return B->Fn(Context, Frame->getArgs());
        }
        default: {
          String* Msg = Context.CreateString(
            "invalid operator for call expression: ",
            Callee->getKindName()
          );
          return Context.SetError(CallLoc, Msg, Callee);
        }
      }

      if(!isa<ApplyOp>(OpTail)) return Visit(OpTail);

      // evaluates arguments in current environment
      EvaluateArgs(cast<ApplyOp>(OpTail), ArgResults);
    }
  }

  heavy::Value* Visit(BindingOp Op) {
    if (auto* B = dyn_cast<heavy::Binding>(getValue(Op))) {
      return B->getValue();
    }
    // create a Binding
    heavy::Value* V = Visit(Op.input());
    heavy::Binding* B = Context.CreateBinding(V);
    setValue(Op.result(), B);
    return Context.CreateUndefined();
  }

  heavy::Value* Visit(BuiltinOp Op) {
    // Map the IR value node to the run-time value
    heavy::Value* V = Op.builtinFn(); 
    setValue(Op.result(), V);
    return V;
  }

  heavy::Value* Visit(LambdaOp Op) {
    return Context.CreateLambdaIr(Op, llvm::None);
  }

  heavy::Value* Visit(LiteralOp Op) {
    // Map the IR value node to the run-time value
    heavy::Value* V = Op.input(); 
    setValue(Op.result(), V);
    return V;
  }

  heavy::Value* Visit(SetOp Op) {
    if (BindingOp BVal = dyn_cast<BindingOp>(Op.binding().getDefiningOp())) {
      assert(BVal && "SetOp binding should be BindingOp");
      heavy::Binding* B = dyn_cast_or_null<heavy::Binding>(getValue(BVal));
      assert(B && "A value for binding must exist");
      heavy::Value* RHS = Visit(Op.input());
      B->Val = RHS;
    }
    return Context.CreateUndefined();
  }

  mlir::Operation* VisitBodyUntilTail(mlir::Block& Body) {
    assert(!Body.empty() && "body must have at least one operation");
    auto TailItr = --Body.end();
    for (auto itr = Body.begin(); itr != TailItr; ++itr) {
      Visit(&*itr);
    }
    return &*TailItr;
  }

#if 0
  // TODO 
  // Visit operations having tail positions within them
  // IfOp, CondOp, SequenceOp
        
  mlir::Operation* VisitUntilTail(IfOp Op) {
    // TODO
  }
#endif
};

}

#endif
