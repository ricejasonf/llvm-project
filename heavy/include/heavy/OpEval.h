//===----- OpEval.h - Classes tree evaluation MLIR Operations ----*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
//  This file defines heavy::OpEval for tree evaluation of ops generated by OpGen
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_HEAVY_OP_EVAL_H
#define LLVM_HEAVY_OP_EVAL_H

#include "heavy/HeavyScheme.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/Support/Casting.h"

namespace heavy {

class OpEval {
  heavy::Context& Context;
  // TODO ValueMap should probably be a scoped
  //      hash table so we can have local values
  //      in function scopes
  llvm::DenseMap<mlir::Value, heavy::Value*> ValueMap;

  struct StackScope {
    heavy::Context& Context;
    // TODO store ScopedHashTableScope
    StackScope(OpEval& E, llvm::ArrayRef<heavy::Value*> Args,
                          SourceLocation CallLoc)
      : Context(E.Context),
        // TODO initialize Scope table thingy
    {
      heavy::StackFrame* Frame = Context.EvalStack.push(Args, CallLoc);
    }

    ~StackScope() {
      Context.EvalStack.pop();
    }
  };

  void setValue(mlir::Value M, heavy::Value* H) {
    ValueMap[M] = H;
  }

  heavy::Value* getValue(mlir::Value M) {
    heavy::Value* V = ValueMap.lookup(M);
    if (!V) {
      return Context.CreateUndefined();
    }
    return V;
  }
  
  static heavy::SourceLocation getSourceLocation(mlir::Location Loc) {
    if (!Loc.isa<mlir::OpaqueLoc>()) return {};
    return heavy::SourceLocation(
      mlir::OpaqueLoc::getUnderlyingLocation<heavy::SourceLocationEncoding*>(
        Loc.cast<mlir::OpaqueLoc>()));
  }

public:
  OpEval(heavy::Context& C)
    : Context(C),
      ValueMap()
  { }

  heavy::Value* Visit(mlir::Value V) {
    return Visit(V.getDefiningOp());
  }

  heavy::Value* Visit(mlir::Operation* Op) {
    // FIXME there has to be a better way to do this
    if (llvm::isa<ApplyOp>(Op))   return Visit(llvm::cast<ApplyOp>(Op));
    if (llvm::isa<BindingOp>(Op)) return Visit(llvm::cast<BindingOp>(Op));
    if (llvm::isa<BuiltinOp>(Op)) return Visit(llvm::cast<BuiltinOp>(Op));
    if (llvm::isa<SetOp>(Op))     return Visit(llvm::cast<SetOp>(Op));
    if (llvm::isa<LiteralOp>(Op)) return Visit(llvm::cast<LiteralOp>(Op));
    if (llvm::isa<LambdaOp>(Op))  return Visit(llvm::cast<LambdaOp>(Op));
    llvm_unreachable("Unknown Operation");
  }

  heavy::Value* Visit(ApplyOp OrigOp) {
    mlir::Operation* OpTail = OrigOp;
    while (ApplyOp Op = dyn_cast<ApplyOp>(OpTail)) {
      heavy::SourceLocation CallLoc = getSourceLocation(Op.getLoc());
      llvm::SmallVector<heavy::Value*, 8> ArgResults(nullptr,
                                                     Op.args.size() + 1);

      // We store args left to right, but we want to evaluate them
      // in reverse order to prevent accidental reliance on unspecified
      // behaviour
      for (int i = Op.args().size() - 1; i >= 0; --i) {
        ArgResults[i](Visit(Op.args()[i]));
      }
      heavy::Value* Callee = Visit(Op.fn());
      ArgsResults[0](Callee);

      StackScope SS(*this, ArgsResults, CallLoc);
      // ^ TODO move this in the RAII object
      // heavy::StackFrame* Frame = Context.EvalStack.push(ArgResults, CallLoc);
       heavy::StackFrame* Frame = SS.getFrame();
      if (!Frame) return Context.CreateUndefined();

      Frame->setCallee(Callee);

      heavy::Value* Result = Context.CreateUndefined();

      switch (Callee->getKind()) {
        case Value::Kind::Lambda:
          llvm_unreachable("TODO");
          break;
        case Value::Kind::LambdaIr:
          llvm_unreachable("TODO");
          LambdaIr* L = cast<LambdaIr>(Callee);
          mlir::Operation* OpTail = VisitBodyUntilTail(L->getOp());
          break;
        case Value::Kind::Builtin: {
          Builtin* B = cast<Builtin>(Callee);
          return B->Fn(Context, Frame->getArgs());
        }
        default: {
          String* Msg = Context.CreateString(
            "invalid operator for call expression: ",
            Callee->getKindName()
          );
          return Context.SetError(CallLoc, Msg, Callee);
        }
      }
    }

    return Visit(OpTail);
  }

  heavy::Value* Visit(BindingOp Op) {
    if (auto* B = dyn_cast<heavy::Binding>(getValue(Op))) {
      return B->getValue();
    }
    // create a Binding
    heavy::Value* V = Visit(Op.input());
    heavy::Binding* B = Context.CreateBinding(V);
    setValue(Op.result(), B);
    return Context.CreateUndefined();
  }

  heavy::Value* Visit(BuiltinOp Op) {
    // Map the IR value node to the run-time value
    heavy::Value* V = Op.builtinFn(); 
    setValue(Op.result(), V);
    return V;
  }

  heavy::Value* Visit(LambdaOp Op) {
    return Context.CreateLambdaIr(Op, llvm::None);
  }

  heavy::Value* Visit(LiteralOp Op) {
    // Map the IR value node to the run-time value
    heavy::Value* V = Op.input(); 
    setValue(Op.result(), V);
    return V;
  }

  heavy::Value* Visit(SetOp Op) {
    if (BindingOp BVal = dyn_cast<BindingOp>(Op.binding().getDefiningOp())) {
      assert(BVal && "SetOp binding should be BindingOp");
      heavy::Binding* B = dyn_cast_or_null<heavy::Binding>(getValue(BVal));
      assert(B && "A value for binding must exist");
      heavy::Value* RHS = Visit(Op.input());
      B->Val = RHS;
    }
    return Context.CreateUndefined();
  }
};

}

#endif
