//===----- OpEval.h - Classes tree evaluation MLIR Operations ----*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
//  This file defines heavy::OpEval for tree evaluation of ops generated by OpGen
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_HEAVY_OP_EVAL_H
#define LLVM_HEAVY_OP_EVAL_H

#include "heavy/HeavyScheme.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/ScopedHashTable.h"
#include "llvm/Support/Casting.h"

namespace heavy {

class OpEvalImpl {
  using BlockItrTy = mlir::Block::iterator;
  using ValueMapTy = llvm::ScopedHashTable<mlir::Value, heavy::Value*>;
  using ValueMapScope = typename ValueMapTy::ScopeTy;

  struct StackScope {
    heavy::Context& Context;
    ValueMapScope ScopeObj;
    heavy::StackFrame* Frame;

    StackScope(OpEvalImpl& E, mlir::Operation* Op,
               llvm::ArrayRef<heavy::Value*> Args)
      : Context(E.Context),
        ScopeObj(E.ValueMap),
        Frame(Context.EvalStack.push(Op))
    {
      llvm::errs() << "pushing StackScope\n";
    }

    StackScope(StackScope const&) = delete;

    ~StackScope() {
      llvm::errs() << "popping StackScope\n";
      Context.EvalStack.pop();
    }
  };

  heavy::Context& Context;
  mlir::Operation* LastIp = nullptr; // the last op evaluated
  ValueMapTy ValueMap;
  std::stack<ValueMapScope> ValueMapScopes;

  void setValue(mlir::Value M, heavy::Value* H) {
    llvm::errs() << "setValue: " << hash_value(M) << '\n';
    assert(M && "must set to a valid value");
    assert(H && "must set to a valid value");
    ValueMap.insert(M, H);
  }

  heavy::Value* getValue(mlir::Value M, bool UnwrapBinding = true) {
    llvm::errs() << "getValue: " << hash_value(M) << '\n';
    heavy::Value* V = ValueMap.lookup(M);
    assert(V && "getValue requires a value in the table");
    //if (!V) return Context.CreateUndefined();
    if (!UnwrapBinding) return V;

    if (Binding* B = dyn_cast<Binding>(V)) {
      V = B->getValue();
    }
    return V;
  }
  
  static heavy::SourceLocation getSourceLocation(mlir::Location Loc) {
    if (!Loc.isa<mlir::OpaqueLoc>()) return {};
    return heavy::SourceLocation(
      mlir::OpaqueLoc::getUnderlyingLocation<heavy::SourceLocationEncoding*>(
        Loc.cast<mlir::OpaqueLoc>()));
  }

public:
  OpEvalImpl(heavy::Context& C)
    : Context(C),
      ValueMap(),
      ValueMapScopes(ValueMapScope(ValueMap))
  { }

  // evaluate the current program up to
  // the last operation in the top level module
  heavy::Value* Run() {
    ModuleOp = TopLevel = Context.getTopLevel();

    if (TopLevel.getBody()->empty()) {
      return Context::CreateUndefined();
    }

    BlockItrTy Itr = LastIp ? LastIp : TopLevel.begin();
    do {
      Itr = Visit(*Itr);
    } while (Itr != TopLevel.end());

    LastIp = *(--Itr);
    return getValue(LastIp->getResult());
  }

private:
  void push_frame(mlir::Operation* Op, llvm::ArrayRef<heavy::Value*> Args) {
    Context.EvalStack.push(Op, Args);
  }

  void pop_frame() {
    Context.EvalStack.pop();
  }

  void next(mlir::Operation* Op) {
    return ++BlockItrTy(Op);
  }

  heavy::Value* Visit(mlir::Value MVal) {
    if (MVal.isa<mlir::OpResult>()) {
      return Visit(MVal.getDefiningOp());
    } else {
      // BlockArgument
      heavy::Value* V = getValue(MVal);
      return V;
    }
  }

  heavy::Value* Visit(mlir::Operation* Op) {
         if (isa<ApplyOp>(Op))      return Visit(cast<ApplyOp>(Op));
    else if (isa<BindingOp>(Op))    return Visit(cast<BindingOp>(Op));
    else if (isa<BuiltinOp>(Op))    return Visit(cast<BuiltinOp>(Op));
    else if (isa<SetOp>(Op))        return Visit(cast<SetOp>(Op));
    else if (isa<LiteralOp>(Op))    return Visit(cast<LiteralOp>(Op));
    else if (isa<LambdaOp>(Op))     return Visit(cast<LambdaOp>(Op));
    else if (UndefinedOp UOp = dyn_cast<UndefinedOp>(Op))  {
      setValue(UOp, Context.CreateUndefined());
      return Context.CreateUndefined();
    }
    else {
      Op->dump();
      llvm_unreachable("Unknown Operation");
      return Context.CreateUndefined();
    }
  }

  void LoadArgs(StackFrame* Frame, mlir::Block& Body) {
    // This associate values with BlockArguments
    // which later gets assigned to BingingOps (in code)

    // Note we are not setting the callee (which might end as a param)
    auto OpArgs = Body.getArguments();
    auto FrameArgs = Frame->getArgs();
    for (unsigned i = 0; i < OpArgs.size(); ++i) {
      setValue(OpArgs[i], FrameArgs[i]);
    }
  }

  void LoadArgResults(ApplyOp Op,
                      llvm::SmallVectorImpl<heavy::Value*>& ArgResults) {
    auto Args = Op.args();
    ArgResults.clear();
    ArgResults.resize(Args.size() + 1);
    for (unsigned i = 0; i < Args.size(); ++i) {
      ArgResults[i + 1] = getValue(Args[i]);
    }
    ArgResults[0] = getValue(Op.fn());
  }

  heavy::Value* Visit(ApplyOp OrigOp) {
    mlir::Operation* OpTail = OrigOp;
    llvm::SmallVector<heavy::Value*, 8> ArgResults;
    LoadArgResults(OrigOp, ArgResults);
    while (true) {
      ApplyOp Op = cast<ApplyOp>(OpTail);
      heavy::SourceLocation CallLoc = getSourceLocation(Op.getLoc());

      StackScope SS(*this, ArgResults, CallLoc);
      heavy::StackFrame* Frame = SS.Frame;
      if (!Frame) return Context.CreateUndefined();

      heavy::Value* Callee = ArgResults[0];
      Frame->setCallee(Callee);

      switch (Callee->getKind()) {
        case Value::Kind::Lambda:
          llvm_unreachable("TODO");
          break;
        case Value::Kind::LambdaIr: {
          LambdaIr* L = cast<LambdaIr>(Callee);
          mlir::Block& Body = L->getBody();
          LoadArgs(Frame, Body);
          OpTail = VisitBodyUntilTail(Body);
          break;
        }
        case Value::Kind::Builtin: {
          Builtin* B = cast<Builtin>(Callee);
          return B->Fn(Context, Frame->getArgs());
        }
        default: {
          String* Msg = Context.CreateString(
            "invalid operator for call expression: ",
            Callee->getKindName()
          );
          return Context.SetError(CallLoc, Msg, Callee);
        }
      }

      if(!isa<ApplyOp>(OpTail)) {
        heavy::Value* Result = Visit(OpTail);
        setValue(OrigOp.result(), Result);
        return Result;
      }

      // Load the ArgResults before StackScope is destroyed
      LoadArgResults(cast<ApplyOp>(OpTail), ArgResults);
    }
  }

  heavy::Value* Visit(BindingOp Op) {
    // create a Binding
    heavy::Value* V = getValue(Op.input());
    heavy::Binding* B = Context.CreateBinding(V);
    setValue(Op.result(), B);
    return B;
  }

  BlockItrTy Visit(BuiltinOp Op) {
    heavy::Value* V = Op.builtinFn(); 
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(ContOp Op) {
    // This is the end of the road for the current block.
    // Get the op after the one in the current frame
    // and then pop the frame
    mlir::Operation* Caller = Context.EvalStack.Top->getOp();
    auto Args = Op.args();
    auto Results = Caller.getResults();
    assert(Args.size() == Results.size() &&
        "continuation must arity must match");
    for (unsigned i = 0; i < Args.size(); 
      setValue(Results 
    }

    pop_frame();
    return next(Caller);
  }

  BlockItrTy Visit(LambdaOp Op) {
    heavy::Value* V = Context.CreateLambdaIr(Op, llvm::None);
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(LiteralOp Op) {
    // Map the IR value node to the run-time value
    heavy::Value* V = Op.input(); 
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(SetOp Op) {
    BindingOp BVal = cast<BindingOp>(Op.binding().getDefiningOp());
    heavy::Binding* B = cast<heavy::Binding>(getValue(BVal,
                                             /*UnwrapBinding=*/false));
    heavy::Value* RHS = getValue(Op.input());
    B->setValue(RHS);
    return next(Op);
  }

  mlir::Operation* GetTail(mlir::Block& Body) {
    assert(!Body.empty() && "body must have at least one operation");
    auto TailItr = --Body.end();
    // For cases where the ContOp takes a single result
    // (that isn't one of bindings)
    // return that Operation as the tail
    ContOp C = dyn_cast<ContOp>(&*TailItr);
    if (!C || C.args().size() > 1) return &*TailItr;

    mlir::Operation* D = C.args().front().getDefiningOp();
    return isa<BindingOp>(D) ? C : D;
  }

  mlir::Operation* VisitBodyUntilTail(mlir::Block& Body) {
    assert(!Body.empty() && "body must have at least one operation");
    mlir::Operation* Tail = GetTail(Body);
    auto TailItr = mlir::Block::iterator(*Tail);
    for (auto itr = Body.begin(); itr != TailItr; ++itr) {
      Visit(&*itr);
    }
    return VisitUntilTail(Tail);
  }

  mlir::Operation* VisitUntilTail(mlir::Operation* Op) {
    // TODO operations like IfOp may contain tail calls
    return Op;
  }

#if 0
  // TODO 
  // Visit operations having tail positions within them
  // IfOp, CondOp, SequenceOp
        
  mlir::Operation* VisitUntilTail(IfOp Op) {
    // TODO
  }
#endif
};

heavy::Value* opEval(OpEval& E) {
  return E.Impl->Run();
}

OpEval::OpEval(heavy::Context& C)
  : Impl(std::make_unique<OpEvalImpl>(C))
{ }

OpEval::~OpEval() = default;

}

#endif
