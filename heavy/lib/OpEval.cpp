//===----- OpEval.h - Classes tree evaluation MLIR Operations ----*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
//  This file defines heavy::OpEval for tree evaluation of ops generated by OpGen
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_HEAVY_OP_EVAL_H
#define LLVM_HEAVY_OP_EVAL_H

#include "heavy/Context.h"
#include "heavy/OpGen.h"
#include "mlir/IR/Module.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/ScopedHashTable.h"
#include "llvm/Support/Casting.h"
#include <stack>

namespace heavy {

class OpEvalImpl {
  using BlockItrTy = mlir::Block::iterator;
  using ValueMapTy = llvm::ScopedHashTable<mlir::Value, heavy::Value>;
  using ValueMapScope = typename ValueMapTy::ScopeTy;

  // FunctionEntryPointTy - Allows IR (not compiled) functions to affect
  //                        control flow.
  //
  class FunctionEntryPointTy {
    BlockItrTy Inst;
    bool IsSet = false;

    public:
    operator bool() const {
      return IsSet;
    }

    void operator=(BlockItrTy B) {
      Inst = B;
      IsSet = true;
    }

    // Gets the instruction and clears the state
    BlockItrTy flush() {
      assert(IsSet && "instruction must be set");
      BlockItrTy Result = Inst;
      Inst = BlockItrTy();
      IsSet = false;
      return Result;
    }
  };

  heavy::Context& Context;
  BlockItrTy LastIp; // the last op evaluated
  ValueMapTy ValueMap;
  std::stack<ValueMapScope> ValueMapScopes;
  FunctionEntryPointTy FunctionEntryPoint = {};

  void setValue(mlir::Value M, heavy::Value H) {
    assert(M && "must be set to a valid value");
    assert(H && "must be set to a valid value");
    ValueMap.insert(M, H);
  }

  heavy::Value getBindingOrValue(mlir::Value M) {

    heavy::Value V = ValueMap.lookup(M);
    if (!V && (M.getDefiningOp<UndefinedOp>() ||
               M.getDefiningOp<SetOp>())) {
      return Context.CreateUndefined();
    }

    if (!V) {
      if (GlobalOp G = M.getDefiningOp<GlobalOp>()) {
        if (G.isExternal()) {
          heavy::Value Val = Context.GetKnownValue(G.sym_name());
          setValue(M, Val);
          return Val;
        }
      }
    }

    if (!V) M.getDefiningOp()->dump();
    // failure here could mean failure to capture in a closure
    assert(V && "getValue requires a value in the table");

    return V;
  }

  heavy::Value getValue(mlir::Value M) {
    heavy::Value V = getBindingOrValue(M);
    if (Binding* B = dyn_cast<Binding>(V)) {
      V = B->getValue();
    }
    return V;
  }

  static heavy::SourceLocation getSourceLocation(mlir::Location Loc) {
    if (!Loc.isa<mlir::OpaqueLoc>()) return {};
    return heavy::SourceLocation(
      mlir::OpaqueLoc::getUnderlyingLocation<heavy::SourceLocationEncoding*>(
        Loc.cast<mlir::OpaqueLoc>()));
  }

public:
  OpEvalImpl(heavy::Context& C)
    : Context(C),
      LastIp(),
      ValueMap(),
      ValueMapScopes()
  {
    // there has to be at least one scope on the stack
    ValueMapScopes.emplace(ValueMap);
  }

  ~OpEvalImpl() {
    // pop the scopes in order
    while (!ValueMapScopes.empty())
      ValueMapScopes.pop();
  }

  heavy::Value Eval(mlir::Operation* Op) {
    assert((isa<GlobalOp, CommandOp>(Op)) &&
          "eval expects a top level op");
    BlockItrTy Itr = Visit(Op);
    // When a call to Visit returns a null we defer
    // execution to the continuation stack.
    while (Itr != BlockItrTy()) {
      Itr = Visit(&*Itr);
    }

    return Context.Resume();
  }

private:
  void push_scope() {
    ValueMapScopes.emplace(ValueMap);
  }

  void pop_scope() {
    ValueMapScopes.pop();
    assert(ValueMapScopes.size() > 0 &&
        "scope stack must be balanced");
  }

  BlockItrTy next(mlir::Operation* Op) {
    return ++BlockItrTy(Op);
  }

  template <typename T>
  BlockItrTy SetError(SourceLocation Loc, T Str, Value V) {
    Context.SetError(Loc, Str, V);

    // TODO unwinding stuff
    while (!ValueMapScopes.empty()) {
      ValueMapScopes.pop();
    }

    return BlockItrTy();
  }

  BlockItrTy Visit(mlir::Operation* Op) {
         if (isa<BindingOp>(Op))      return Visit(cast<BindingOp>(Op));
    else if (isa<LiteralOp>(Op))      return Visit(cast<LiteralOp>(Op));
    else if (isa<ApplyOp>(Op))        return Visit(cast<ApplyOp>(Op));
    else if (isa<BuiltinOp>(Op))      return Visit(cast<BuiltinOp>(Op));
    else if (isa<ContOp>(Op))         return Visit(cast<ContOp>(Op));
    else if (isa<GlobalOp>(Op))       return Visit(cast<GlobalOp>(Op));
    else if (isa<LoadClosureOp>(Op))  return Visit(cast<LoadClosureOp>(Op));
    else if (isa<LoadGlobalOp>(Op))   return Visit(cast<LoadGlobalOp>(Op));
    else if (isa<LambdaOp>(Op))       return Visit(cast<LambdaOp>(Op));
    else if (isa<IfOp>(Op))           return Visit(cast<IfOp>(Op));
    else if (isa<ConsOp>(Op))         return Visit(cast<ConsOp>(Op));
    else if (isa<SpliceOp>(Op))       return Visit(cast<SpliceOp>(Op));
    else if (isa<SetOp>(Op))          return Visit(cast<SetOp>(Op));
    else if (isa<CommandOp>(Op))      return Visit(cast<CommandOp>(Op));
    else if (isa<FuncOp>(Op))         return next(Op); // skip functions
    else if (isa<mlir::ModuleTerminatorOp>(Op)) return {};
    else if (UndefinedOp UndefOp = dyn_cast<UndefinedOp>(Op)) {
      setValue(UndefOp, Context.CreateUndefined());
      return next(Op);
    }
    else {
      Op->dump();
      llvm_unreachable("unknown operation");
      return BlockItrTy();
    }
  }

  void LoadArgs(mlir::Block& Body, ValueRefs Args) {
    // This associates values with BlockArguments
    // which later gets assigned to BingingOps (in code)

    auto OpArgs = Body.getArguments();
    assert(OpArgs.size() == Args.size() + 1
        && "arity should be checked already");
    // OpArg[0] is always the context object
    for (unsigned i = 0; i < Args.size(); ++i) {
      setValue(OpArgs[i + 1], Args[i]);
    }
  }

  BlockItrTy CallFuncOp(heavy::FuncOp F, ValueRefs Args) {
    SourceLocation CallLoc = getSourceLocation(F.getLoc());
    // check arguments
    {
      unsigned NumArgs = Args.size();
      mlir::FunctionType FT = F.getTypeAttr()
                               .getValue()
                               .cast<mlir::FunctionType>();
      // assert(!F.hasRestParam() && "TODO support rest parameters");
      // The function type includes the Context as a parameter
      if (FT.getNumInputs() != NumArgs + 1) {
        return SetError(CallLoc, "invalid arity", heavy::Undefined());
      }
    }

    push_scope();
    mlir::Block& Body = F.getBody().front();
    LoadArgs(Body, Args);
    BlockItrTy Itr = Body.begin();
    while (Itr != BlockItrTy()) {
      Itr = Visit(&*Itr);
    }
    // Something in the function should have
    // called Context.Apply() or one of those
    return BlockItrTy();
  }

  // LoadArgResults
  //  - Loads the values input to the ApplyOp
  //  - Note that the arguments do not map directly
  //    to the callees function parameters
  void LoadArgResults(ApplyOp Op,
                      llvm::SmallVectorImpl<heavy::Value>& ArgResults) {
    auto Args = Op.args();
    ArgResults.clear();
    ArgResults.resize(Args.size() + 1);
    for (unsigned i = 0; i < Args.size(); ++i) {
      ArgResults[i + 1] = getValue(Args[i]);
    }
    ArgResults[0] = getValue(Op.fn());
  }

  // SetContValues
  //  - Loads the values for the results of an Op
  //  - Used by ContOp and ApplyOp (since ApplyOp is dynamic)
  //  - Checks arity
  void SetContValues(mlir::Operation* Op, ValueRefs ContValues) {
    auto Results = Op->getResults();
    assert((Results.empty() ||
           Results.size() == ContValues.size()) &&
        "continuation arity must match");

    for (unsigned i = 0; i < Results.size(); ++i) {
      setValue(Results[i], ContValues[i]);
    }
  }

  BlockItrTy Visit(ApplyOp Op) {
    heavy::SourceLocation CallLoc = getSourceLocation(Op.getLoc());

    llvm::SmallVector<heavy::Value, 8> ArgResults;
    LoadArgResults(Op, ArgResults);
    Value Callee = ArgResults[0];
    ValueRefs Args = ValueRefs(ArgResults).drop_front();

    if (Op.isTailPos()) {
      Context.Apply(CallLoc, Callee, Args);
      return BlockItrTy();
    }

    // TODO Handle non-tail Apply which requires
    //      setting up a continuation
    //      To make this work with call/cc we have
    //      to actually capture the values via something
    //      like a PushContOp
    //
    //      Right now we are just resuming with the next Op
    Context.PushCont([this, Op](heavy::Context& C, ValueRefs ContValues) {
      SetContValues(Op, ContValues);

      BlockItrTy Itr = next(Op);
      // When a call to Visit returns a null we defer
      // execution to the continuation stack.
      while (Itr != BlockItrTy()) {
        Itr = Visit(&*Itr);
      }
      return Undefined{};
    }, llvm::None);
    Context.Apply(Callee, Args);
    return BlockItrTy();
  }

  BlockItrTy Visit(BindingOp Op) {
    // create a Binding
    heavy::Value V = getValue(Op.input());
    heavy::Binding* B = Context.CreateBinding(V);
    setValue(Op.result(), B);
    return next(Op);
  }

  BlockItrTy Visit(BuiltinOp Op) {
    heavy::Value V = Op.builtinFn();
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(ConsOp Op) {
    heavy::Value A = getValue(Op.a());
    heavy::Value B = getValue(Op.b());
    heavy::Pair* V = Context.CreatePair(A, B);
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(ContOp Op) {
    // This is the end of the road for the current block.
    // For functions the continuation is dynamic and we
    // must use the current stack frame to find the next
    // operation. For all others the continuation is fixed.
    auto ContArgs = Op.args();
    llvm::SmallVector<heavy::Value, 1> ContValues(ContArgs.size(),
                                                  nullptr);
    for (unsigned i = 0; i < ContArgs.size(); ++i) {
      ContValues[i] = getValue(ContArgs[i]);
    }

    pop_scope();

    mlir::Operation* Parent = Op.getParentOp();

    if (isa<FuncOp>(Parent)) {
      // The continuation is handled by the run-time
      Context.Cont(ContValues);
      return {};
    } else if (isa<GlobalOp>(Parent)) {
      // mutable globals must be wrapped with a binding
      assert(ContValues.size() == 1 &&
          "GlobalOp should have only one result");
      ContValues[0] = Context.CreateBinding(ContValues[0]);
    }

    SetContValues(Parent, ContValues);

    if (isa<mlir::ModuleOp>(Parent->getParentOp())) {
      // stop after top level op
      Context.Cont(heavy::Undefined());
      return {};
    }

    return next(Parent);
  }

  BlockItrTy Visit(IfOp Op) {
    Value Input = getValue(Op.input());
    push_scope();
    return Input.isTrue() ? Op.thenRegion().front().begin() :
                            Op.elseRegion().front().begin();
  }

  BlockItrTy Visit(LambdaOp Op) {
    // We could use the symbol to lookup the function
    // but here we just assume the FuncOp precedes the LambdaOp
    // since they are always generated that way in OpGen
    FuncOp F = cast<FuncOp>(Op.getOperation()->getPrevNode());
    llvm::SmallVector<heavy::Value, 8> Captures;
    for (mlir::Value Val : Op.captures()) {
      Captures.push_back(getBindingOrValue(Val));
    }

    auto CallFn = [this, F](heavy::Context& C, ValueRefs Args) {
      this->CallFuncOp(F, Args);
      return heavy::Undefined();
    };

    Lambda* L = Context.CreateLambda(CallFn, Captures);

    setValue(Op.result(), L);
    return next(Op);
  }

  BlockItrTy Visit(LiteralOp Op) {
    // Map the IR value node to the run-time value
    heavy::Value V = Op.input();
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(LoadClosureOp Op) {
    // get the Lambda object and get its
    // closure value and set it to the value
    uint32_t Index = Op.index().getZExtValue();

    // We are assuming we will only ever get a
    // closure element from the current callee.
    // heavy::Value Closure = getValue(Op.closure());
    heavy::Value Closure = Context.getCallee();

    heavy::Value V = nullptr;

    if (auto* C = dyn_cast<Lambda>(Closure)) {
      V = C->getCaptures()[Index];
    }

    assert(V && "must have a valid closure type");

    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(LoadGlobalOp Op) {
    mlir::ModuleOp M = Context.OpGen->getTopLevel();
    mlir::Operation* G = M.lookupSymbol(Op.name());
    assert(G && "symbol does not exist");
    setValue(Op, getBindingOrValue(G->getResult(0)));
    return next(Op);
  }

  BlockItrTy Visit(GlobalOp Op) {
    // skip external global ops
    if (Op.isExternal()) return next(Op);

    push_scope();
    return Op.initializer().front().begin();
  }

  BlockItrTy Visit(CommandOp Op) {
    push_scope();
    return Op.body().front().begin();
  }

  BlockItrTy Visit(SetOp Op) {
    heavy::Binding* B = cast<heavy::Binding>(getBindingOrValue(Op.binding()));
    heavy::Value RHS = getValue(Op.input());
    B->setValue(RHS);
    return next(Op);
  }

  BlockItrTy Visit(SpliceOp Op) {
    heavy::SourceLocation Loc = getSourceLocation(Op.getLoc());
    heavy::Value LHS = getValue(Op.a());
    heavy::Value RHS = getValue(Op.b());

    // must both be lists
    if (!isa<heavy::Pair>(LHS) && !isa<heavy::Empty>(LHS)) {
      return SetError(Loc, "splicing operand expected list", LHS);
    }
    if (!isa<heavy::Pair>(RHS) && !isa<heavy::Empty>(RHS)) {
      return SetError(Loc, "splicing operand expected list", RHS);
    }

    // A new list must be created
    // Dummy is the start point that is not part of the result
    // as it is not on the heap
    heavy::Pair Dummy = heavy::Pair(nullptr, nullptr);
    heavy::Pair* Dest = &Dummy;
    heavy::Value Temp = LHS;

    while (Pair* Cur = dyn_cast<heavy::Pair>(Temp)) {
      heavy::Pair* New = Context.CreatePair(Cur->Car);
      Dest->Cdr = New;
      Dest = New;
      Temp = Cur->Cdr;
    }
    Temp = RHS;
    while (Pair* Cur = dyn_cast<heavy::Pair>(Temp)) {
      heavy::Pair* New = Context.CreatePair(Cur->Car);
      Dest->Cdr = New;
      Dest = New;
      Temp = Cur->Cdr;
    }
    heavy::Value Result = Dummy.Cdr ? Dummy.Cdr : Empty{};
    setValue(Op, Result);
    return next(Op);
  }
};

heavy::Value opEval(OpEval& E, mlir::Operation* Op) {
  return E.Impl->Eval(Op);
}

OpEval::OpEval(heavy::Context& C)
  : Impl(std::make_unique<OpEvalImpl>(C))
{ }

OpEval::~OpEval() = default;

}

#endif
