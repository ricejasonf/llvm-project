//===----- OpEval.h - Classes tree evaluation MLIR Operations ----*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
//  This file defines heavy::OpEval for tree evaluation of ops generated by OpGen
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_HEAVY_OP_EVAL_H
#define LLVM_HEAVY_OP_EVAL_H

#include "heavy/HeavyScheme.h"
#include "heavy/OpGen.h"
#include "mlir/IR/Module.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/ScopedHashTable.h"
#include "llvm/Support/Casting.h"
#include <stack>

namespace heavy {

class OpEvalImpl {
  using BlockItrTy = mlir::Block::iterator;
  using ValueMapTy = llvm::ScopedHashTable<mlir::Value, heavy::Value>;
  using ValueMapScope = typename ValueMapTy::ScopeTy;

  heavy::Context& Context;
  BlockItrTy LastIp; // the last op evaluated
  ValueMapTy ValueMap;
  std::stack<ValueMapScope> ValueMapScopes;

  void setValue(mlir::Value M, heavy::Value H) {
    assert(M && "must be set to a valid value");
    assert(H && "must be set to a valid value");
    ValueMap.insert(M, H);
  }

  heavy::Value getBindingOrValue(mlir::Value M) {
    heavy::Value V = ValueMap.lookup(M);
    if (!V && (M.getDefiningOp<UndefinedOp>() ||
               M.getDefiningOp<SetOp>())) {
      return Context.CreateUndefined();
    }

    // failure here could mean failure to capture in a closure
    assert(V && "getValue requires a value in the table");

    return V;
  }

  heavy::Value getValue(mlir::Value M) {
    heavy::Value V = getBindingOrValue(M);
    if (Binding* B = dyn_cast<Binding>(V)) {
      V = B->getValue();
    }
    return V;
  }

  heavy::StackFrame& getCurrentFrame() {
    return *Context.EvalStack.top();
  }
  
  static heavy::SourceLocation getSourceLocation(mlir::Location Loc) {
    if (!Loc.isa<mlir::OpaqueLoc>()) return {};
    return heavy::SourceLocation(
      mlir::OpaqueLoc::getUnderlyingLocation<heavy::SourceLocationEncoding*>(
        Loc.cast<mlir::OpaqueLoc>()));
  }

public:
  OpEvalImpl(heavy::Context& C)
    : Context(C),
      LastIp(),
      ValueMap(),
      ValueMapScopes()
  {
    // there has to be at least one scope on the stack
    ValueMapScopes.emplace(ValueMap);
  }

  // Evaluate expressions inserted at the top level.
  // Subsequent calls resume from the last expression evaluated
  // to allow REPL like behaviour
  heavy::Value Run() {
    mlir::ModuleOp TopLevel = Context.OpGen->getTopLevel();
    BlockItrTy End(TopLevel.getBody()->getTerminator());

    BlockItrTy Itr;
    if (LastIp == BlockItrTy()) {
      Itr = TopLevel.begin();
    } else {
      Itr = LastIp;
      ++Itr;
    }

    if (Itr == End) return Context.CreateUndefined();
    do {
      Itr = Visit(&*Itr);
    } while (Itr != BlockItrTy() && Itr != End);

    if (Itr == BlockItrTy() ||
        Context.CheckError()) return Context.CreateUndefined();

    LastIp = --Itr;
    return getValue(LastIp->getResult(0));
  }

private:
  heavy::StackFrame* push_frame(mlir::Operation* Op, llvm::ArrayRef<heavy::Value> Args) {
      // llvm::errs() << "push_frame: "; Op->dump();
    assert(Op && "stack frame op must be a valid op");
    ValueMapScopes.emplace(ValueMap);
    return Context.EvalStack.push(Op, Args);
  }

  void pop_frame()  {
      // llvm::errs() << "pop_frame:  "; getCurrentFrame().getOp()->dump();
    Context.EvalStack.pop();
    ValueMapScopes.pop();
  }

  void pop_tail_calls() {
    // since some frames aren't calls we have to iterate until
    // we get a non-tail call
    while (true) {
      ApplyOp Caller = dyn_cast_or_null<ApplyOp>(getCurrentFrame().getOp());
      if (!Caller || !Caller.isTailPos()) break;
      pop_frame();
    }
  }

  BlockItrTy next(mlir::Operation* Op) {
    return ++BlockItrTy(Op);
  }

  template <typename T>
  BlockItrTy SetError(SourceLocation Loc, T Str, Value V) {
    Context.SetError(Loc, Str, V);

    // TODO unwinding stuff
    while (!ValueMapScopes.empty()) {
      ValueMapScopes.pop();
    }

    return BlockItrTy();
  }

#if 0
  heavy::Value Visit(mlir::Value MVal) {
    if (MVal.isa<mlir::OpResult>()) {
      return Visit(MVal.getDefiningOp());
    } else {
      // BlockArgument
      heavy::Value V = getValue(MVal);
      return V;
    }
  }
#endif

  BlockItrTy Visit(mlir::Operation* Op) {
         if (isa<BindingOp>(Op))      return Visit(cast<BindingOp>(Op));
    else if (isa<LiteralOp>(Op))      return Visit(cast<LiteralOp>(Op));
    else if (isa<ApplyOp>(Op))        return Visit(cast<ApplyOp>(Op));
    else if (isa<BuiltinOp>(Op))      return Visit(cast<BuiltinOp>(Op));
    else if (isa<ContOp>(Op))         return Visit(cast<ContOp>(Op));
    else if (isa<LoadClosureOp>(Op))  return Visit(cast<LoadClosureOp>(Op));
    else if (isa<LoadGlobalOp>(Op))   return Visit(cast<LoadGlobalOp>(Op));
    else if (isa<LambdaOp>(Op))       return Visit(cast<LambdaOp>(Op));
    else if (isa<IfOp>(Op))           return Visit(cast<IfOp>(Op));
    else if (isa<SetOp>(Op))          return Visit(cast<SetOp>(Op));
    else if (isa<FuncOp>(Op))         return next(Op); // skip functions
    else if (UndefinedOp UndefOp = dyn_cast<UndefinedOp>(Op))  {
      setValue(UndefOp, Context.CreateUndefined());
      return next(Op);
    }
    else {
      Op->dump();
      llvm_unreachable("unknown operation");
      return BlockItrTy();
    }
  }

  void LoadArgs(StackFrame* Frame, mlir::Block& Body) {
    // This associates values with BlockArguments
    // which later gets assigned to BingingOps (in code)

    // Note we are not setting the callee (which might end up as a param)
    auto OpArgs = Body.getArguments();
    auto FrameArgs = Frame->getArgs();
    for (unsigned i = 0; i < OpArgs.size(); ++i) {
      setValue(OpArgs[i], FrameArgs[i]);
    }
  }

  BlockItrTy CallLambdaIr(heavy::ApplyOp ApplyOp, heavy::LambdaIr* L,
                          llvm::ArrayRef<heavy::Value> Args) {
    heavy::SourceLocation CallLoc = getSourceLocation(ApplyOp.getLoc());
    heavy::FuncOp F = L->getOp();

    // check arguments
    {
      unsigned NumArgs = Args.size();
      mlir::FunctionType FT = F.getTypeAttr()
                               .getValue()
                               .cast<mlir::FunctionType>();
      // assert(!F.hasRestParam() && "TODO support rest parameters");
      if (FT.getNumInputs() != NumArgs) {
        return SetError(CallLoc, "invalid arity", L);
      }
    }

    heavy::StackFrame* Frame = push_frame(ApplyOp, Args);
    if (!Frame) return BlockItrTy();

    mlir::Block& Body = L->getBody();
    LoadArgs(Frame, Body);
    // return the first instruction of the function body
    return BlockItrTy(Body.front());
  }

  void LoadArgResults(ApplyOp Op,
                      llvm::SmallVectorImpl<heavy::Value>& ArgResults) {
    auto Args = Op.args();
    ArgResults.clear();
    ArgResults.resize(Args.size() + 1);
    for (unsigned i = 0; i < Args.size(); ++i) {
      ArgResults[i + 1] = getValue(Args[i]);
    }
    ArgResults[0] = getValue(Op.fn());
  }

  BlockItrTy Visit(ApplyOp Op) {
    heavy::SourceLocation CallLoc = getSourceLocation(Op.getLoc());
    llvm::SmallVector<heavy::Value, 8> ArgResults;
    LoadArgResults(Op, ArgResults);
    heavy::Value Callee = ArgResults[0];

    // Now that we have ArgResults, we can pop the call frame
    // before any tail call
    // (we want keep the original call that is not in tail position)
    if (Op.isTailPos()) {
      pop_tail_calls();
    }

    switch (Callee.getKind()) {
      case ValueKind::Lambda:
        llvm_unreachable("TODO");
        break;
      case ValueKind::LambdaIr: {
        LambdaIr* L = cast<LambdaIr>(Callee);
        return CallLambdaIr(Op, L, ArgResults);
      }
      case ValueKind::Builtin: {
        llvm::ArrayRef<heavy::Value> ArgResultsRef(ArgResults);
        Builtin* B = cast<Builtin>(Callee);

        heavy::Value Result = B->Fn(Context,
                                     ArgResultsRef.drop_front());
        if (isa<Error>(Result)) return BlockItrTy();
        setValue(Op.result(), Result);
        return next(Op);
      }
      default: {
        String* Msg = Context.CreateString(
          "invalid operator for call expression: ",
          getKindName(Callee.getKind())
        );
        return SetError(CallLoc, Msg, Callee);
      }
    }
  }

  BlockItrTy Visit(BindingOp Op) {
    // create a Binding
    heavy::Value V = getValue(Op.input());
    heavy::Binding* B = Context.CreateBinding(V);
    setValue(Op.result(), B);
    return next(Op);
  }

  BlockItrTy Visit(BuiltinOp Op) {
    heavy::Value V = Op.builtinFn(); 
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(ContOp Op) {
    // This is the end of the road for the current block.
    // Get the op after the one in the current frame
    // and then pop the frame
    auto ContArgs = Op.args();
    llvm::SmallVector<heavy::Value, 1> ContValues(ContArgs.size(),
                                                   nullptr);
    for (unsigned i = 0; i < ContArgs.size(); ++i) {
      ContValues[i] = getValue(ContArgs[i]); 
    }

    mlir::Operation* Caller = getCurrentFrame().getOp();
    assert(Caller && "heavy.cont op must return to a valid stack frame");
    auto Results = Caller->getResults();
    assert((Results.empty() ||
           Results.size() == ContArgs.size()) &&
        "continuation arity must match");

    // if this isn't receiving a tail call
    // then pop the frame
    ApplyOp AppOp = ContArgs[0].getDefiningOp<ApplyOp>();
    if (!AppOp || AppOp.isTailPos()) {
      pop_frame();
    }

    for (unsigned i = 0; i < Results.size(); ++i) {
      setValue(Results[i], ContValues[i]); 
    }

    return next(Caller);
  }

  BlockItrTy Visit(IfOp Op) {
    Value Input = getValue(Op.input());
    // only explicit boolean false is considered false
    bool CondResult = !isa<Bool>(Input) || !cast<Bool>(Input);
    push_frame(Op, llvm::None);
    return CondResult ? Op.thenRegion().front().begin() :
                        Op.elseRegion().front().begin();
  }

  BlockItrTy Visit(LambdaOp Op) {
    // We could use the symbol to lookup the function
    // but here we just assume the FuncOp precedes the LambdaOp
    // since they are always generated that way in OpGen
    FuncOp F = cast<FuncOp>(Op.getOperation()->getPrevNode());
    llvm::SmallVector<heavy::Value, 8> Captures;
    for (mlir::Value Val : Op.captures()) {
      Captures.push_back(getBindingOrValue(Val));
    }
      
    heavy::Value V = Context.CreateLambdaIr(F, Captures);
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(LiteralOp Op) {
    // Map the IR value node to the run-time value
    heavy::Value V = Op.input(); 
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(LoadClosureOp Op) {
    // get the Lambda object and get its
    // closure value and set it to the value
    uint32_t Index = Op.index().getZExtValue();
    heavy::Value Closure = getValue(Op.closure());
    heavy::Value V = nullptr;
    if (auto* C = dyn_cast<LambdaIr>(Closure)) {
      V = C->getCaptures()[Index];
    }

    assert(V && "must have a valid closure type");

    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(LoadGlobalOp Op) {
    mlir::ModuleOp M = Context.OpGen->getTopLevel();
    mlir::Operation* G = M.lookupSymbol(Op.name());
    setValue(Op, getValue(G->getResult(0)));
    return next(Op);
  }

  BlockItrTy Visit(SetOp Op) {
    heavy::Binding* B = cast<heavy::Binding>(getBindingOrValue(Op.binding()));
    heavy::Value RHS = getValue(Op.input());
    B->setValue(RHS);
    return next(Op);
  }

#if 0 // hopefully won't need this GetTail stuff anymore
  mlir::Operation* GetTail(mlir::Block& Body) {
    assert(!Body.empty() && "body must have at least one operation");
    auto TailItr = --Body.end();
    // For cases where the ContOp takes a single result
    // (that isn't one of bindings)
    // return that Operation as the tail
    ContOp C = dyn_cast<ContOp>(&*TailItr);
    if (!C || C.args().size() > 1) return &*TailItr;

    mlir::Operation* D = C.args().front().getDefiningOp();
    return isa<BindingOp>(D) ? C : D;
  }

  mlir::Operation* VisitBodyUntilTail(mlir::Block& Body) {
    assert(!Body.empty() && "body must have at least one operation");
    mlir::Operation* Tail = GetTail(Body);
    auto TailItr = mlir::Block::iterator(*Tail);
    for (auto itr = Body.begin(); itr != TailItr; ++itr) {
      Visit(&*itr);
    }
    return VisitUntilTail(Tail);
  }

  mlir::Operation* VisitUntilTail(mlir::Operation* Op) {
    // TODO operations like IfOp may contain tail calls
    return Op;
  }
#endif

#if 0
  // TODO 
  // Visit operations having tail positions within them
  // IfOp, CondOp, SequenceOp
        
  mlir::Operation* VisitUntilTail(IfOp Op) {
    // TODO
  }
#endif
};

heavy::Value opEval(OpEval& E) {
  return E.Impl->Run();
}

OpEval::OpEval(heavy::Context& C)
  : Impl(std::make_unique<OpEvalImpl>(C))
{ }

OpEval::~OpEval() = default;

}

#endif
