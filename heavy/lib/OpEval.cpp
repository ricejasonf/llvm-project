//===--- OpEval.cpp - Classes tree evaluation MLIR Operations ----*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
//  This file defines heavy::OpEval for tree evaluation of ops generated by OpGen
//
//===----------------------------------------------------------------------===//

#include "heavy/Builtins.h"
#include "heavy/Context.h"
#include "heavy/OpGen.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/ScopedHashTable.h"
#include "llvm/Support/Casting.h"
#include <stack>

namespace heavy {

class OpEvalImpl {
  using BlockItrTy = mlir::Block::iterator;
  using ValueMapTy = llvm::ScopedHashTable<mlir::Value, heavy::Value>;
  using ValueMapScope = typename ValueMapTy::ScopeTy;

  heavy::Context& Context;
  ValueMapTy ValueMap;
  std::stack<ValueMapScope> ValueMapScopes;

  void setValue(mlir::Value M, heavy::Value H) {
    assert(M && "must be set to a valid value");
    assert(H && "must be set to a valid value");
    ValueMap.insert(M, H);
  }

  heavy::Value getBindingOrValue(mlir::Value M) {
    assert(M && "lookup requires a valid value");
    heavy::Value V = ValueMap.lookup(M);
    if (!V && (M.getDefiningOp<UndefinedOp>() ||
               M.getDefiningOp<SetOp>())) {
      return Context.CreateUndefined();
    }

    if (!V) {
      if (GlobalOp G = M.getDefiningOp<GlobalOp>()) {
        if (G.isExternal()) {
          heavy::Value Val = Context.GetKnownValue(G.sym_name());
          setValue(M, Val);
          return Val;
        }
      }
    }

    // failure here could mean failure to capture in a closure
    assert(V && "getValue requires a value in the table");

    return V;
  }

  heavy::Value getValue(mlir::Value M) {
    heavy::Value V = getBindingOrValue(M);
    if (Binding* B = dyn_cast<Binding>(V)) {
      V = B->getValue();
    }
    return V;
  }

  static heavy::SourceLocation getSourceLocation(mlir::Location Loc) {
    if (!Loc.isa<mlir::OpaqueLoc>()) return {};
    return heavy::SourceLocation(
      mlir::OpaqueLoc::getUnderlyingLocation<heavy::SourceLocationEncoding*>(
        Loc.cast<mlir::OpaqueLoc>()));
  }

public:
  OpEvalImpl(heavy::Context& C)
    : Context(C),
      ValueMap(),
      ValueMapScopes()
  {
    // there has to be at least one scope on the stack
    ValueMapScopes.emplace(ValueMap);
  }

  // Prevent copy/move since we capture this in a few lambdas.
  OpEvalImpl(OpEvalImpl const&) = delete;

  ~OpEvalImpl() {
    // pop the scopes in order
    while (!ValueMapScopes.empty())
      ValueMapScopes.pop();
  }

  void Eval(mlir::Operation* Op) {
    if (isa<GlobalOp, CommandOp>(Op)) {
      BlockItrTy Itr = Visit(Op);
      // When a call to Visit returns a null we defer
      // execution to the continuation stack.
      while (Itr != BlockItrTy()) {
        Itr = Visit(&*Itr);
      }
      // "Calling the continuation" is handled during visitation.
    } else if (auto ModuleOp = dyn_cast<mlir::ModuleOp>(Op)) {

      // FIXME ExportOp should not even be handled here as it is
      //       purely a compile-time operation.
      // Find the ExportOp and push it first so it always runs last.
      auto& Ops = ModuleOp.getBody()->getOperations();
      for (auto i = Ops.rbegin(); i != Ops.rend(); ++i) {
        mlir::Operation* TL = &*i;
        if (auto E = dyn_cast<ExportOp>(TL)) {
          Context.PushCont([this, E](heavy::Context& C, ValueRefs) mutable {
            this->VisitExportOp(E);
          }, CaptureList{});
          break;
        }
      }
      for (auto i = Ops.rbegin(); i != Ops.rend(); ++i) {
        mlir::Operation* TL = &*i;
        auto G = dyn_cast<GlobalOp>(TL);
        // External GlobalOps are skipped so we need to skip them
        // here as well.
        if ((G && !G.isExternal()) || isa<CommandOp>(TL)) {
          Context.PushCont([this, TL](heavy::Context& C, ValueRefs) mutable {
            this->Eval(TL);
          }, CaptureList{});
        }
      }
      Context.Cont();
      return;
    } else {
      SetError("op_eval expects a top level op");
    }
  }

  // InvokeSyntax - There is no operation to invoke syntax
  //                so provide an interface to functions
  //                to wrap non-compiled SyntaxOps.
  void InvokeSyntax(SyntaxOp Op, Value Input) {
    // Bind the Input to the block argument
    setValue(Op.region().getArgument(0), Input);
    mlir::Block& Body = Op.region().front();
    BlockItrTy Itr = Body.begin();
    // Enter the first pattern.
    auto PatternOp = cast<heavy::PatternOp>(*Itr);
    push_scope();
    Itr = PatternOp.region().front().begin();
    while (Itr != BlockItrTy()) {
      Itr = Visit(&*Itr);
    }
  }

private:
  void push_scope() {
    ValueMapScopes.emplace(ValueMap);
  }

  void pop_scope() {
    ValueMapScopes.pop();
    assert(ValueMapScopes.size() > 0 &&
        "scope stack must be balanced");
  }

  BlockItrTy next(mlir::Operation* Op) {
    return ++BlockItrTy(Op);
  }

  template <typename Message, typename Irritants>
  BlockItrTy RaiseError(Message M, Irritants Irrs) {
    Context.RaiseError(M, Irrs);

    // TODO use DynamicWind to create/destroy ValueMapScopes
    while (!ValueMapScopes.empty()) {
      ValueMapScopes.pop();
    }

    return BlockItrTy();
  }

  template <typename ...Args>
  BlockItrTy SetError(Args... args) {
    Context.SetError(args...);

    // TODO use DynamicWind to create/destroy ValueMapScopes
    while (!ValueMapScopes.empty()) {
      ValueMapScopes.pop();
    }

    return BlockItrTy();
  }

  BlockItrTy Visit(mlir::Operation* Op) {
         if (isa<BindingOp>(Op))      return Visit(cast<BindingOp>(Op));
    else if (isa<LiteralOp>(Op))      return Visit(cast<LiteralOp>(Op));
    else if (isa<ApplyOp>(Op))        return Visit(cast<ApplyOp>(Op));
    else if (isa<BuiltinOp>(Op))      return Visit(cast<BuiltinOp>(Op));
    else if (isa<ContOp>(Op))         return Visit(cast<ContOp>(Op));
    else if (isa<GlobalOp>(Op))       return Visit(cast<GlobalOp>(Op));
    else if (isa<LoadClosureOp>(Op))  return Visit(cast<LoadClosureOp>(Op));
    else if (isa<LoadGlobalOp>(Op))   return Visit(cast<LoadGlobalOp>(Op));
    else if (isa<LambdaOp>(Op))       return Visit(cast<LambdaOp>(Op));
    else if (isa<IfOp>(Op))           return Visit(cast<IfOp>(Op));
    else if (isa<IfContOp>(Op))       return Visit(cast<IfContOp>(Op));
    else if (isa<ConsOp>(Op))         return Visit(cast<ConsOp>(Op));
    else if (isa<SpliceOp>(Op))       return Visit(cast<SpliceOp>(Op));
    else if (isa<SetOp>(Op))          return Visit(cast<SetOp>(Op));
    else if (isa<CommandOp>(Op))      return Visit(cast<CommandOp>(Op));
    else if (isa<PushContOp>(Op))     return Visit(cast<PushContOp>(Op));
    else if (isa<OpGenOp>(Op))        return Visit(cast<OpGenOp>(Op));
    else if (isa<FuncOp>(Op))         return next(Op); // skip functions
    else if (isa<SyntaxOp>(Op))       return Visit(cast<SyntaxOp>(Op));
    else if (isa<MatchPairOp>(Op))    return Visit(cast<MatchPairOp>(Op));
    else if (isa<MatchOp>(Op))        return Visit(cast<MatchOp>(Op));
    else if (isa<RenameOp>(Op))       return Visit(cast<RenameOp>(Op));
    else if (isa<SyntaxClosureOp>(Op))
      return Visit(cast<SyntaxClosureOp>(Op));
    else if (UndefinedOp UndefOp = dyn_cast<UndefinedOp>(Op)) {
      setValue(UndefOp, Context.CreateUndefined());
      return next(Op);
    }
    else {
      Op->dump();
      llvm_unreachable("unknown operation");
      return BlockItrTy();
    }
  }

  void LoadArgs(mlir::Block& Body, ValueRefs Args) {
    // This associates values with BlockArguments
    // which later gets assigned to BingingOps (in code)

    auto OpArgs = Body.getArguments();
    assert(OpArgs.size() >= Args.size() + 1
        && "arity should be checked already");
    // OpArg[0] is always the context object
    for (unsigned i = 0; i < Args.size(); ++i) {
      setValue(OpArgs[i + 1], Args[i]);
    }
  }

  BlockItrTy CallFuncOp(heavy::FuncOp F, ValueRefs Args) {
    SourceLocation CallLoc = getSourceLocation(F.getLoc());
    heavy::Value RestList;
    // check arguments
    unsigned NumArgs = Args.size();
    mlir::FunctionType FT = F.getTypeAttr()
                             .getValue()
                             .cast<mlir::FunctionType>();
    // The functions type includes the argument
    // for the context object.
    unsigned NumParams = FT.getNumInputs() - 1;
    if (NumParams > 0 && FT.getInputs().back().isa<HeavyRestTy>()) {
      // Handle a rest param.
      // Check that the number of explicit params
      // are less than the amount of arguments.
      //int NumExplicitArgsMatched = NumParams - 1 - NumArgs;
      if (NumArgs < NumParams - 1) {
        return SetError(CallLoc, "invalid arity", heavy::Undefined());
      }

      ValueRefs RestArgs = Args.slice(NumParams - 1, NumArgs - (NumParams - 1));
      Args = Args.drop_back(RestArgs.size());
      RestList = Context.CreateList(RestArgs);
    } else {
      // The function type includes the Context as a parameter
      if (NumParams != NumArgs) {
        return SetError(CallLoc, "invalid arity", heavy::Undefined());
      }
    }

    push_scope();
    mlir::Block& Body = F.getBody().front();
    LoadArgs(Body, Args);
    if (RestList) {
      setValue(Body.getArguments().back(), RestList);
    }
    BlockItrTy Itr = Body.begin();
    while (Itr != BlockItrTy()) {
      Itr = Visit(&*Itr);
    }
    // Something in the function should have
    // called Context.Apply() or one of those
    return BlockItrTy();
  }

  // LoadArgResults
  //  - Loads the values input to the ApplyOp
  //  - Note that the arguments do not map directly
  //    to the callees function parameters
  void LoadArgResults(ApplyOp Op,
                      llvm::SmallVectorImpl<heavy::Value>& ArgResults) {
    auto Args = Op.args();
    ArgResults.clear();
    ArgResults.resize(Args.size() + 1);
    for (unsigned i = 0; i < Args.size(); ++i) {
      ArgResults[i + 1] = getValue(Args[i]);
    }
    ArgResults[0] = getValue(Op.fn());
  }

  // SetContValues
  //  - Loads the values for the results of an Op
  //  - Used by ContOp and ApplyOp (since ApplyOp is dynamic)
  //  - Checks arity
  //
  // TODO I think this should be replaced with a ResultOp and
  //      ContOp always call the current continuation
  void SetContValues(mlir::Operation* Op, ValueRefs ContValues) {
    auto Results = Op->getResults();
    assert((Results.empty() ||
           Results.size() == ContValues.size()) &&
        "continuation arity must match");

    for (unsigned i = 0; i < Results.size(); ++i) {
      setValue(Results[i], ContValues[i]);
    }
  }

  BlockItrTy Visit(ApplyOp Op) {
    llvm::SmallVector<heavy::Value, 8> ArgResults;
    LoadArgResults(Op, ArgResults);
    Value Callee = ArgResults[0];
    ValueRefs Args = ValueRefs(ArgResults).drop_front();

    if (!Op.isTailPos()) {
      // evaluate the initCont region which pushes
      // a continuation
      BlockItrTy Itr = Op.initCont().front().begin();
      while (Itr != BlockItrTy()) {
        Itr = Visit(&*Itr);
      }
    }

    Context.Apply(Callee, Args);
    return BlockItrTy();
  }

  BlockItrTy Visit(BindingOp Op) {
    // create a Binding
    heavy::Value V = Op.input() ? getValue(Op.input()) :
                                  heavy::Undefined();
    heavy::Binding* B = Context.CreateBinding(V);
    setValue(Op.result(), B);
    return next(Op);
  }

  BlockItrTy Visit(BuiltinOp Op) {
    heavy::Value V = Op.builtinFn();
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(ConsOp Op) {
    // TODO Use PairWithSource to retain source location information.
    heavy::Value A = getValue(Op.a());
    heavy::Value B = getValue(Op.b());
    heavy::Pair* V = Context.CreatePair(A, B);
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(ContOp Op) {
    // This is the end of the road for the current block.
    // For functions the continuation is dynamic and we
    // must use the current stack frame to find the next
    // operation. For all others the continuation is fixed.
    auto ContArgs = Op.args();
    llvm::SmallVector<heavy::Value, 1> ContValues(ContArgs.size(),
                                                  nullptr);
    for (unsigned i = 0; i < ContArgs.size(); ++i) {
      ContValues[i] = getValue(ContArgs[i]);
    }

    pop_scope();

    mlir::Operation* Parent = Op->getParentOp();

    if (isa<FuncOp, GlobalOp, IfContOp>(Parent)) {
      // The continuation is handled by the run-time
      Context.Cont(ContValues);
      return {};
    }

    SetContValues(Parent, ContValues);

    if (isa<mlir::ModuleOp>(Parent->getParentOp())) {
      // stop after top level op
      Context.Cont(heavy::Undefined());
      return {};
    }

    return next(Parent);
  }

  BlockItrTy Visit(IfOp Op) {
    Value Input = getValue(Op.input());
    push_scope();
    return Input.isTrue() ? Op.thenRegion().front().begin() :
                            Op.elseRegion().front().begin();
  }

  BlockItrTy Visit(IfContOp Op) {
    Value Input = getValue(Op.input());

    if (!Op.isTailPos()) {
      // evaluate the initCont region which pushes
      // a continuation
      BlockItrTy Itr = Op.initCont().front().begin();
      while (Itr != BlockItrTy()) {
        Itr = Visit(&*Itr);
      }
    }

    push_scope();
    return Input.isTrue() ? Op.thenRegion().front().begin() :
                            Op.elseRegion().front().begin();
  }

  auto createClosure(mlir::Operation* Op, mlir::ValueRange CaptureVals,
                     llvm::SmallVectorImpl<heavy::Value>& Captures) {
    for (mlir::Value Val : CaptureVals) {
      Captures.push_back(getBindingOrValue(Val));
    }

    // We could use the symbol to lookup the function
    // but here we just assume the FuncOp precedes the
    // LambdaOp/PushContOp since they are always
    // generated that way in OpGen.
    FuncOp F = cast<FuncOp>(Op->getPrevNode());
    return [this, F](heavy::Context& C, ValueRefs Args) {
      // FIXME EvalOp instance can be destroyed before this.
      this->CallFuncOp(F, Args);
      return heavy::Undefined();
    };
  }

  BlockItrTy Visit(LambdaOp Op) {
    llvm::SmallVector<heavy::Value, 8> Captures;
    auto CallFn = createClosure(Op, Op.captures(), Captures);
    Lambda* L = Context.CreateLambda(CallFn, Captures);

    setValue(Op.result(), L);
    return next(Op);
  }

  BlockItrTy Visit(PushContOp Op) {
    llvm::SmallVector<heavy::Value, 8> Captures;
    auto CallFn = createClosure(Op, Op.captures(), Captures);
    Context.PushCont(CallFn, Captures);

    return BlockItrTy();
  }

  BlockItrTy Visit(LiteralOp Op) {
    // Map the IR value node to the run-time value
    heavy::Value V = Op.input();
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(LoadClosureOp Op) {
    // get the Lambda object and get its
    // closure value and set it to the value
    uint32_t Index = Op.index();

    // We are assuming we will only ever get a
    // closure element from the current callee.
    // heavy::Value Closure = getValue(Op.closure());
    heavy::Value Closure = Context.getCallee();

    heavy::Value V = nullptr;

    if (auto* C = dyn_cast<Lambda>(Closure)) {
      V = C->getCaptures()[Index];
    }

    assert(V && "must have a valid closure type");

    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(LoadGlobalOp Op) {
    Value Val = Context.GetKnownValue(Op.name());
    if (!Val) {
      Val = Undefined();
    }
    setValue(Op, Val);
    return next(Op);
  }

  BlockItrTy Visit(GlobalOp Op) {
    // skip external global ops
    if (Op.isExternal()) return next(Op);

    push_scope();
    Context.PushCont([Op](heavy::Context& C, ValueRefs Args) mutable {
      assert(Args.size() == 1 && "invalid continuation arity");
      // Mutable globals must be wrapped with a binding
      Value Binding = C.CreateBinding(Args[0]);
      C.AddKnownAddress(Op.sym_name(), Binding);
      C.Cont(Undefined());
    }, ValueRefs());

    return Op.initializer().front().begin();
  }

  BlockItrTy Visit(CommandOp Op) {
    push_scope();
    return Op.body().front().begin();
  }

  BlockItrTy Visit(SetOp Op) {
    heavy::Binding* B = cast<heavy::Binding>(getBindingOrValue(Op.binding()));
    heavy::Value RHS = getValue(Op.input());
    B->setValue(RHS);
    return next(Op);
  }

  BlockItrTy Visit(SpliceOp Op) {
    heavy::SourceLocation Loc = getSourceLocation(Op.getLoc());
    heavy::Value LHS = getValue(Op.a());
    heavy::Value RHS = getValue(Op.b());

    // must both be lists
    if (!isa<heavy::Pair>(LHS) && !isa<heavy::Empty>(LHS)) {
      return SetError(Loc, "splicing operand expected list", LHS);
    }
    if (!isa<heavy::Pair>(RHS) && !isa<heavy::Empty>(RHS)) {
      return SetError(Loc, "splicing operand expected list", RHS);
    }

    // A new list must be created
    // Dummy is the start point that is not part of the result
    // as it is not on the heap
    heavy::Pair Dummy = heavy::Pair(nullptr, nullptr);
    heavy::Pair* Dest = &Dummy;
    heavy::Value Temp = LHS;

    while (Pair* Cur = dyn_cast<heavy::Pair>(Temp)) {
      heavy::Pair* New = Context.CreatePair(Cur->Car);
      Dest->Cdr = New;
      Dest = New;
      Temp = Cur->Cdr;
    }
    Temp = RHS;
    while (Pair* Cur = dyn_cast<heavy::Pair>(Temp)) {
      heavy::Pair* New = Context.CreatePair(Cur->Car);
      Dest->Cdr = New;
      Dest = New;
      Temp = Cur->Cdr;
    }
    heavy::Value Result = Dummy.Cdr ? Dummy.Cdr : Empty{};
    setValue(Op, Result);
    return next(Op);
  }

  BlockItrTy gotoNextPattern(mlir::Operation* O) {
    // We should currently be in the scope of a PatternOp
    assert((isa<MatchOp, MatchPairOp>(O)) &&
        "Operation must be a pattern matcher");
    mlir::Operation* PatternOp = O->getParentOp();
    assert(isa<heavy::PatternOp>(PatternOp) &&
        "PatternOp should be a PatternOpOp.");
    // Abort the current pattern's scope
    pop_scope();
    mlir::Operation* NextNode = PatternOp->getNextNode();
    if (!NextNode) {
      heavy::SourceLocation Loc = getSourceLocation(O->getLoc());
      Context.OpGen->SetError(Loc, "no matching pattern for syntax",
                              Undefined());
      return BlockItrTy();
    }
    // Enter the next pattern
    push_scope();
    return cast<heavy::PatternOp>(*NextNode).region().front().begin();
  }

  BlockItrTy Visit(MatchOp Op) {
    heavy::Value P = Op.val();
    heavy::Value E = getValue(Op.input());
    if (equal(P, E)) {
      return next(Op);
    }
    return gotoNextPattern(Op);
  }

  BlockItrTy Visit(MatchPairOp Op) {
    heavy::Value E = getValue(Op.input());
    if (auto* Pair = dyn_cast<heavy::Pair>(E)) {
      setValue(Op.car(), Pair->Car);
      setValue(Op.cdr(), Pair->Cdr);
      return next(Op);
    }
    return gotoNextPattern(Op);
  }

  BlockItrTy Visit(SyntaxOp Op) {
    // Evaluate iff this is a global.
    if (isa<GlobalOp>(Op->getParentOp())) {
      heavy::Syntax* Syntax = Context.CreateSyntaxWithOp(Op);
      setValue(Op.result(), Syntax);
    }
    return next(Op);
  }

  BlockItrTy Visit(SyntaxClosureOp Op) {
    // Create a SyntaxClosure with the current
    // EnvStack.
    heavy::Value Input = getValue(Op.input());
    SyntaxClosure* SC = Context.CreateSyntaxClosure(Input);
    setValue(Op.result(), SC);
    return next(Op);
  }

  BlockItrTy Visit(RenameOp Op) {
    // :O
    void* OV = reinterpret_cast<void*>(Op.opaqueValue());
    mlir::Value MV = mlir::Value::getFromOpaquePointer(OV);
    heavy::Value HV = heavy::OpGen::fromValue(MV);
    setValue(Op.result(), HV);
    return next(Op);
  }

  BlockItrTy Visit(OpGenOp Op) {
    heavy::Value Input = getValue(Op.input());
    if (!Op.isTailPos()) {
      // evaluate the initCont region which pushes
      // a continuation
      BlockItrTy Itr = Op.initCont().front().begin();
      while (Itr != BlockItrTy()) {
        Itr = Visit(&*Itr);
      }
    }
    mlir::Value Result = Context.OpGen->Visit(Input);
    heavy::Value Output = heavy::OpGen::fromValue(Result);
    if (!Context.CheckError()) {
      Context.Cont(Output);
    }
    return BlockItrTy();
  }

  // VisitExportOp - Register export vars with Context. Always run this
  //                 after the module init function. (ie Evaluating the ModuleOp)
  void VisitExportOp(ExportOp Op) {
    // Walk all of the ExportIdOps registering
    // the exported names with Context.
    llvm::StringRef ModuleName =
      cast<mlir::ModuleOp>(Op.getOperation()->getParentOp())
        .getName()
        .getValueOr("");
    if (ModuleName.empty()) {
      SourceLocation Loc = getSourceLocation(Op.getLoc());
      SetError(Loc, "module must have symbol", Undefined());
      return;
    }
    Module* M = Context.Modules[ModuleName].get();
    assert(M && "module should be registered");
    mlir::Block& Body = Op.body().back();
    for (mlir::Operation& X : Body.getOperations()) {
      if (auto IdOp = dyn_cast<ExportIdOp>(X)) {
        Value Val = Context.GetKnownValue(IdOp.symbolName());
        if (!Val) {
          SourceLocation Loc = getSourceLocation(IdOp.getLoc());
          SetError(Loc, "export of undefined value", Undefined());
          return;
        }
        registerModuleVar(Context, M, IdOp.symbolName(), IdOp.id(), Val);
      }
    }
    Context.Cont();
  }
};

void invokeSyntaxOp(heavy::Context& C, mlir::Operation* Op,
                    heavy::Value Value) {
  OpEvalImpl E(C);
  auto SyntaxOp = cast<heavy::SyntaxOp>(Op);
  E.InvokeSyntax(SyntaxOp, Value);
}

namespace base {
void op_eval(Context& C, ValueRefs Args) {
  if (Args.size() != 1) {
    return C.RaiseError("invalid arity");
  }
  mlir::Operation* Op = dyn_cast<mlir::Operation>(Args[0]);
  if (!Op) {
    return C.RaiseError("expecting operation");
  }

  // TODO Make the module own the OpEval instance. (maybe?)
  if (!C.OpEval) {
    C.OpEval = new OpEvalImpl(C);
    C.PushModuleCleanup(HEAVY_BASE_LIB_STR,
      C.CreateLambda([](Context& C, ValueRefs) {
        assert(C.OpEval && "OpEval should be set.");
        // Cleanup the OpEval object.
        delete C.OpEval;
      }, CaptureList{}));
  }

  C.OpEval->Eval(Op);
}
}

}
