//===----- OpEval.h - Classes tree evaluation MLIR Operations ----*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
//  This file defines heavy::OpEval for tree evaluation of ops generated by OpGen
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_HEAVY_OP_EVAL_H
#define LLVM_HEAVY_OP_EVAL_H

#include "heavy/Context.h"
#include "heavy/OpGen.h"
#include "mlir/IR/Module.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/ScopedHashTable.h"
#include "llvm/Support/Casting.h"
#include <stack>

namespace heavy {

class OpEvalImpl {
  using BlockItrTy = mlir::Block::iterator;
  using ValueMapTy = llvm::ScopedHashTable<mlir::Value, heavy::Value>;
  using ValueMapScope = typename ValueMapTy::ScopeTy;

  heavy::Context& Context;
  BlockItrTy LastIp; // the last op evaluated
  ValueMapTy ValueMap;
  std::stack<ValueMapScope> ValueMapScopes;

  void setValue(mlir::Value M, heavy::Value H) {
    assert(M && "must be set to a valid value");
    assert(H && "must be set to a valid value");
    ValueMap.insert(M, H);
  }

  heavy::Value getBindingOrValue(mlir::Value M) {
    heavy::Value V = ValueMap.lookup(M);
    if (!V && (M.getDefiningOp<UndefinedOp>() ||
               M.getDefiningOp<SetOp>())) {
      return Context.CreateUndefined();
    }

    // failure here could mean failure to capture in a closure
    assert(V && "getValue requires a value in the table");

    return V;
  }

  heavy::Value getValue(mlir::Value M) {
    heavy::Value V = getBindingOrValue(M);
    if (Binding* B = dyn_cast<Binding>(V)) {
      V = B->getValue();
    }
    return V;
  }

  heavy::StackFrame& getCurrentFrame() {
    return *Context.EvalStack.top();
  }

  static heavy::SourceLocation getSourceLocation(mlir::Location Loc) {
    if (!Loc.isa<mlir::OpaqueLoc>()) return {};
    return heavy::SourceLocation(
      mlir::OpaqueLoc::getUnderlyingLocation<heavy::SourceLocationEncoding*>(
        Loc.cast<mlir::OpaqueLoc>()));
  }

public:
  OpEvalImpl(heavy::Context& C)
    : Context(C),
      LastIp(),
      ValueMap(),
      ValueMapScopes()
  {
    // there has to be at least one scope on the stack
    ValueMapScopes.emplace(ValueMap);
  }

  ~OpEvalImpl() {
    // pop the scopes in order
    while (!ValueMapScopes.empty())
      ValueMapScopes.pop();
  }

  // Evaluate expressions inserted at the top level.
  // Subsequent calls resume from the last expression evaluated
  // to allow REPL like behaviour
  heavy::Value Run() {
    mlir::ModuleOp TopLevel = Context.OpGen->getTopLevel();
    BlockItrTy End(TopLevel.getBody()->getTerminator());

    BlockItrTy Itr;
    if (LastIp == BlockItrTy()) {
      Itr = TopLevel.begin();
    } else {
      Itr = LastIp;
      ++Itr;
    }

    if (Itr == End) return Context.CreateUndefined();
    do {
      Itr = Visit(&*Itr);
    } while (Itr != BlockItrTy() && Itr != End);

    if (Itr == BlockItrTy() ||
        Context.CheckError()) return Context.CreateUndefined();

    LastIp = --Itr;
    return getValue(LastIp->getResult(0));
  }

private:
  heavy::StackFrame* push_frame(mlir::Operation* Op, llvm::ArrayRef<heavy::Value> Args) {
      // llvm::errs() << "push_frame: "; Op->dump();
    assert(Op && "stack frame op must be a valid op");
    ValueMapScopes.emplace(ValueMap);
    return Context.EvalStack.push(Op, Args);
  }

  void pop_frame()  {
      // llvm::errs() << "pop_frame:  "; getCurrentFrame().getOp()->dump();
    Context.EvalStack.pop();
    ValueMapScopes.pop();
  }

  void pop_tail_calls() {
    // since some frames aren't calls we have to iterate until
    // we get a non-tail call
    while (true) {
      ApplyOp Caller = dyn_cast_or_null<ApplyOp>(getCurrentFrame().getOp());
      if (!Caller || !Caller.isTailPos()) break;
      pop_frame();
    }
  }

  BlockItrTy next(mlir::Operation* Op) {
    return ++BlockItrTy(Op);
  }

  template <typename T>
  BlockItrTy SetError(SourceLocation Loc, T Str, Value V) {
    Context.SetError(Loc, Str, V);

    // TODO unwinding stuff
    while (!ValueMapScopes.empty()) {
      ValueMapScopes.pop();
    }

    return BlockItrTy();
  }

#if 0
  heavy::Value Visit(mlir::Value MVal) {
    if (MVal.isa<mlir::OpResult>()) {
      return Visit(MVal.getDefiningOp());
    } else {
      // BlockArgument
      heavy::Value V = getValue(MVal);
      return V;
    }
  }
#endif

  BlockItrTy Visit(mlir::Operation* Op) {
         if (isa<BindingOp>(Op))      return Visit(cast<BindingOp>(Op));
    else if (isa<LiteralOp>(Op))      return Visit(cast<LiteralOp>(Op));
    else if (isa<ApplyOp>(Op))        return Visit(cast<ApplyOp>(Op));
    else if (isa<BuiltinOp>(Op))      return Visit(cast<BuiltinOp>(Op));
    else if (isa<ContOp>(Op))         return Visit(cast<ContOp>(Op));
    else if (isa<LoadClosureOp>(Op))  return Visit(cast<LoadClosureOp>(Op));
    else if (isa<LoadGlobalOp>(Op))   return Visit(cast<LoadGlobalOp>(Op));
    else if (isa<LambdaOp>(Op))       return Visit(cast<LambdaOp>(Op));
    else if (isa<IfOp>(Op))           return Visit(cast<IfOp>(Op));
    else if (isa<ConsOp>(Op))         return Visit(cast<ConsOp>(Op));
    else if (isa<SpliceOp>(Op))       return Visit(cast<SpliceOp>(Op));
    else if (isa<SetOp>(Op))          return Visit(cast<SetOp>(Op));
    else if (isa<FuncOp>(Op))         return next(Op); // skip functions
    else if (UndefinedOp UndefOp = dyn_cast<UndefinedOp>(Op))  {
      setValue(UndefOp, Context.CreateUndefined());
      return next(Op);
    }
    else {
      Op->dump();
      llvm_unreachable("unknown operation");
      return BlockItrTy();
    }
  }

  void LoadArgs(StackFrame* Frame, mlir::Block& Body) {
    // This associates values with BlockArguments
    // which later gets assigned to BingingOps (in code)

    // Note we are not setting the callee (which might end up as a param)
    auto OpArgs = Body.getArguments();
    auto FrameArgs = Frame->getArgs();
    for (unsigned i = 0; i < OpArgs.size(); ++i) {
      setValue(OpArgs[i], FrameArgs[i]);
    }
  }

  BlockItrTy CallLambdaIr(heavy::ApplyOp ApplyOp, heavy::LambdaIr* L,
                          llvm::ArrayRef<heavy::Value> Args) {
    heavy::SourceLocation CallLoc = getSourceLocation(ApplyOp.getLoc());
    heavy::FuncOp F = L->getOp();

    // check arguments
    {
      unsigned NumArgs = Args.size();
      mlir::FunctionType FT = F.getTypeAttr()
                               .getValue()
                               .cast<mlir::FunctionType>();
      // assert(!F.hasRestParam() && "TODO support rest parameters");
      if (FT.getNumInputs() != NumArgs) {
        return SetError(CallLoc, "invalid arity", L);
      }
    }

    heavy::StackFrame* Frame = push_frame(ApplyOp, Args);
    if (!Frame) return BlockItrTy();

    mlir::Block& Body = L->getBody();
    LoadArgs(Frame, Body);
    // return the first instruction of the function body
    return BlockItrTy(Body.front());
  }

  void LoadArgResults(ApplyOp Op,
                      llvm::SmallVectorImpl<heavy::Value>& ArgResults) {
    auto Args = Op.args();
    ArgResults.clear();
    ArgResults.resize(Args.size() + 1);
    for (unsigned i = 0; i < Args.size(); ++i) {
      ArgResults[i + 1] = getValue(Args[i]);
    }
    ArgResults[0] = getValue(Op.fn());
  }

  BlockItrTy Visit(ApplyOp Op) {
    heavy::SourceLocation CallLoc = getSourceLocation(Op.getLoc());
    llvm::SmallVector<heavy::Value, 8> ArgResults;
    LoadArgResults(Op, ArgResults);
    heavy::Value Callee = ArgResults[0];

    // Now that we have ArgResults, we can pop the call frame
    // before any tail call
    // (keep the original call that is not in tail position)
    if (Op.isTailPos()) {
      pop_tail_calls();
    }

    switch (Callee.getKind()) {
      case ValueKind::Lambda:
        llvm_unreachable("TODO");
        break;
      case ValueKind::LambdaIr: {
        LambdaIr* L = cast<LambdaIr>(Callee);
        return CallLambdaIr(Op, L, ArgResults);
      }
      case ValueKind::Builtin: {
        llvm::MutableArrayRef<heavy::Value> ArgResultsRef(ArgResults);
        Builtin* B = cast<Builtin>(Callee);

        heavy::Value Result = B->Fn(Context,
                                     ArgResultsRef.drop_front());
        if (isa<Error>(Result)) return BlockItrTy();
        setValue(Op.result(), Result);
        return next(Op);
      }
      default: {
        String* Msg = Context.CreateString(
          "invalid operator for call expression: ",
          getKindName(Callee.getKind())
        );
        return SetError(CallLoc, Msg, Callee);
      }
    }
  }

  BlockItrTy Visit(BindingOp Op) {
    // create a Binding
    heavy::Value V = getValue(Op.input());
    heavy::Binding* B = Context.CreateBinding(V);
    setValue(Op.result(), B);
    return next(Op);
  }

  BlockItrTy Visit(BuiltinOp Op) {
    heavy::Value V = Op.builtinFn();
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(ConsOp Op) {
    heavy::Value A = getValue(Op.a());
    heavy::Value B = getValue(Op.b());
    heavy::Pair* V = Context.CreatePair(A, B);
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(ContOp Op) {
    // This is the end of the road for the current block.
    // For functions the continuation is dynamic and we
    // must use the current stack frame to find the next
    // operation. For all others the continuation is fixed.
    auto ContArgs = Op.args();
    llvm::SmallVector<heavy::Value, 1> ContValues(ContArgs.size(),
                                                  nullptr);
    for (unsigned i = 0; i < ContArgs.size(); ++i) {
      ContValues[i] = getValue(ContArgs[i]);
    }

    mlir::Operation* Parent = Op.getParentOp();
    mlir::Operation* Caller = getCurrentFrame().getOp();
    assert(Caller && "heavy.cont op must return to a valid stack frame");

    if (Parent != Caller) {
      // The continuation is on the stack frame
      // If this isn't receiving a tail call
      // then pop the frame (for tail calls this was done earlier)
      ApplyOp AppOp = ContArgs[0].getDefiningOp<ApplyOp>();
      if (!AppOp || AppOp.isTailPos()) {
        pop_frame();
      }
    } else {
      Caller = Parent;
    }

    auto Results = Caller->getResults();
    assert((Results.empty() ||
           Results.size() == ContArgs.size()) &&
        "continuation arity must match");

    for (unsigned i = 0; i < Results.size(); ++i) {
      setValue(Results[i], ContValues[i]);
    }

    return next(Caller);

  }

  BlockItrTy Visit(IfOp Op) {
    Value Input = getValue(Op.input());
    return Input.isTrue() ? Op.thenRegion().front().begin() :
                            Op.elseRegion().front().begin();
  }

  BlockItrTy Visit(LambdaOp Op) {
    // We could use the symbol to lookup the function
    // but here we just assume the FuncOp precedes the LambdaOp
    // since they are always generated that way in OpGen
    FuncOp F = cast<FuncOp>(Op.getOperation()->getPrevNode());
    llvm::SmallVector<heavy::Value, 8> Captures;
    for (mlir::Value Val : Op.captures()) {
      Captures.push_back(getBindingOrValue(Val));
    }

    heavy::Value V = Context.CreateLambdaIr(F, Captures);
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(LiteralOp Op) {
    // Map the IR value node to the run-time value
    heavy::Value V = Op.input();
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(LoadClosureOp Op) {
    // get the Lambda object and get its
    // closure value and set it to the value
    uint32_t Index = Op.index().getZExtValue();
    heavy::Value Closure = getValue(Op.closure());
    heavy::Value V = nullptr;
    if (auto* C = dyn_cast<LambdaIr>(Closure)) {
      V = C->getCaptures()[Index];
    }

    assert(V && "must have a valid closure type");

    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(LoadGlobalOp Op) {
    mlir::ModuleOp M = Context.OpGen->getTopLevel();
    mlir::Operation* G = M.lookupSymbol(Op.name());
    setValue(Op, getValue(G->getResult(0)));
    return next(Op);
  }

  BlockItrTy Visit(SetOp Op) {
    heavy::Binding* B = cast<heavy::Binding>(getBindingOrValue(Op.binding()));
    heavy::Value RHS = getValue(Op.input());
    B->setValue(RHS);
    return next(Op);
  }

  BlockItrTy Visit(SpliceOp Op) {
    heavy::SourceLocation Loc = getSourceLocation(Op.getLoc());
    heavy::Value LHS = getValue(Op.a());
    heavy::Value RHS = getValue(Op.b());

    // must both be lists
    if (!isa<heavy::Pair>(LHS) && !isa<heavy::Empty>(LHS)) {
      return SetError(Loc, "splicing operand expected list", LHS);
    }
    if (!isa<heavy::Pair>(RHS) && !isa<heavy::Empty>(RHS)) {
      return SetError(Loc, "splicing operand expected list", RHS);
    }

    // A new list must be created
    // Dummy is the start point that is not part of the result
    // as it is not on the heap
    heavy::Pair Dummy = heavy::Pair(nullptr, nullptr);
    heavy::Pair* Dest = &Dummy;
    heavy::Value Temp = LHS;

    while (Pair* Cur = dyn_cast<heavy::Pair>(Temp)) {
      heavy::Pair* New = Context.CreatePair(Cur->Car);
      Dest->Cdr = New;
      Dest = New;
      Temp = Cur->Cdr;
    }
    Temp = RHS;
    while (Pair* Cur = dyn_cast<heavy::Pair>(Temp)) {
      heavy::Pair* New = Context.CreatePair(Cur->Car);
      Dest->Cdr = New;
      Dest = New;
      Temp = Cur->Cdr;
    }
    heavy::Value Result = Dummy.Cdr ? Dummy.Cdr : Empty{};
    setValue(Op, Result);
    return next(Op);
  }
};

heavy::Value opEval(OpEval& E) {
  return E.Impl->Run();
}

OpEval::OpEval(heavy::Context& C)
  : Impl(std::make_unique<OpEvalImpl>(C))
{ }

OpEval::~OpEval() = default;

}

#endif
