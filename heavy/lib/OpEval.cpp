//===----- OpEval.h - Classes tree evaluation MLIR Operations ----*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
//  This file defines heavy::OpEval for tree evaluation of ops generated by OpGen
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_HEAVY_OP_EVAL_H
#define LLVM_HEAVY_OP_EVAL_H

#include "heavy/HeavyScheme.h"
#include "heavy/OpGen.h"
#include "mlir/IR/Module.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/ScopedHashTable.h"
#include "llvm/Support/Casting.h"
#include <stack>

namespace heavy {

class OpEvalImpl {
  using BlockItrTy = mlir::Block::iterator;
  using ValueMapTy = llvm::ScopedHashTable<mlir::Value, heavy::Value*>;
  using ValueMapScope = typename ValueMapTy::ScopeTy;

  heavy::Context& Context;
  BlockItrTy LastIp; // the last op evaluated
  ValueMapTy ValueMap;
  std::stack<ValueMapScope> ValueMapScopes;

  void setValue(mlir::Value M, heavy::Value* H) {
    llvm::errs() << "setValue: " << hash_value(M) << '\n';
    assert(M && "must set to a valid value");
    assert(H && "must set to a valid value");
    ValueMap.insert(M, H);
  }

  heavy::Value* getValue(mlir::Value M, bool UnwrapBinding = true) {
    llvm::errs() << "getValue: " << hash_value(M) << '\n';
    heavy::Value* V = ValueMap.lookup(M);
    assert(V && "getValue requires a value in the table");
    //if (!V) return Context.CreateUndefined();
    if (!UnwrapBinding) return V;

    if (Binding* B = dyn_cast<Binding>(V)) {
      V = B->getValue();
    }
    return V;
  }
  
  static heavy::SourceLocation getSourceLocation(mlir::Location Loc) {
    if (!Loc.isa<mlir::OpaqueLoc>()) return {};
    return heavy::SourceLocation(
      mlir::OpaqueLoc::getUnderlyingLocation<heavy::SourceLocationEncoding*>(
        Loc.cast<mlir::OpaqueLoc>()));
  }

public:
  OpEvalImpl(heavy::Context& C)
    : Context(C),
      LastIp(),
      ValueMap(),
      ValueMapScopes()
  {
    // there has to be at least one scope on the stack
    ValueMapScopes.emplace(ValueMap);
  }

  // Evaluate expressions inserted at the top level.
  // Subsequent calls resume from the last expression evaluated
  // to allow REPL like behaviour
  heavy::Value* Run() {
    mlir::ModuleOp TopLevel = Context.OpGen->getTopLevel();
    BlockItrTy End = TopLevel.end();

    BlockItrTy Itr;
    if (LastIp == BlockItrTy()) {
      Itr = TopLevel.begin();
    } else {
      Itr = LastIp;
      ++Itr;
    }

    if (Itr == End) return Context.CreateUndefined();
    do {
      Itr = Visit(&*Itr);
    } while (Itr != BlockItrTy() && Itr != End);

    if (Itr == BlockItrTy() ||
        Context.CheckError()) return Context.CreateUndefined();

    LastIp = --Itr;
    return getValue(LastIp->getResult(0));
  }

private:
  heavy::StackFrame* push_frame(mlir::Operation* Op, llvm::ArrayRef<heavy::Value*> Args) {
    ValueMapScopes.emplace(ValueMap);
    return Context.EvalStack.push(Op, Args);
  }
  void pop_frame()  {
    Context.EvalStack.pop();
    ValueMapScopes.pop();
  }

  BlockItrTy next(mlir::Operation* Op) {
    return ++BlockItrTy(Op);
  }

  template <typename T>
  BlockItrTy SetError(SourceLocation Loc, T Str, Value* V) {
    Context.SetError(Loc, Str, V);
    // TODO we eventually want to unwind and stuff here
    return BlockItrTy();
  }

#if 0
  heavy::Value* Visit(mlir::Value MVal) {
    if (MVal.isa<mlir::OpResult>()) {
      return Visit(MVal.getDefiningOp());
    } else {
      // BlockArgument
      heavy::Value* V = getValue(MVal);
      return V;
    }
  }
#endif

  BlockItrTy Visit(mlir::Operation* Op) {
         if (isa<ApplyOp>(Op))      return Visit(cast<ApplyOp>(Op));
    else if (isa<BindingOp>(Op))    return Visit(cast<BindingOp>(Op));
    else if (isa<BuiltinOp>(Op))    return Visit(cast<BuiltinOp>(Op));
    else if (isa<SetOp>(Op))        return Visit(cast<SetOp>(Op));
    else if (isa<LiteralOp>(Op))    return Visit(cast<LiteralOp>(Op));
    else if (isa<LambdaOp>(Op))     return Visit(cast<LambdaOp>(Op));
    else if (UndefinedOp UndefOp = dyn_cast<UndefinedOp>(Op))  {
      setValue(UndefOp, Context.CreateUndefined());
      return next(Op);
    }
    else {
      Op->dump();
      llvm_unreachable("Unknown Operation");
      return BlockItrTy();
    }
  }

  void LoadArgs(StackFrame* Frame, mlir::Block& Body) {
    // This associates values with BlockArguments
    // which later gets assigned to BingingOps (in code)

    // Note we are not setting the callee (which might end up as a param)
    auto OpArgs = Body.getArguments();
    auto FrameArgs = Frame->getArgs();
    for (unsigned i = 0; i < OpArgs.size(); ++i) {
      setValue(OpArgs[i], FrameArgs[i]);
    }
  }

  BlockItrTy CallLambdaIr(heavy::ApplyOp ApplyOp, heavy::LambdaIr* L,
                          llvm::ArrayRef<heavy::Value*> Args) {
    heavy::SourceLocation CallLoc = getSourceLocation(ApplyOp.getLoc());
    heavy::LambdaOp LambdaOp = L->getOp();

    // check arguments
    {
      mlir::FunctionType FT = LambdaOp.type().cast<mlir::FunctionType>();
      assert(!LambdaOp.hasRestParam() && "TODO support rest parameters");
      if (FT.getNumInputs() != Args.size()) {
        return SetError(CallLoc, "invalid arity", L);
      }
    }

    heavy::StackFrame* Frame = push_frame(LambdaOp, Args);
    if (!Frame) return BlockItrTy();

    mlir::Block& Body = L->getBody();
    LoadArgs(Frame, Body);
    // return the first instruction of the function body
    return BlockItrTy(Body.front());
  }

  void LoadArgResults(ApplyOp Op,
                      llvm::SmallVectorImpl<heavy::Value*>& ArgResults) {
    auto Args = Op.args();
    ArgResults.clear();
    ArgResults.resize(Args.size() + 1);
    for (unsigned i = 0; i < Args.size(); ++i) {
      ArgResults[i + 1] = getValue(Args[i]);
    }
    ArgResults[0] = getValue(Op.fn());
  }

  BlockItrTy Visit(ApplyOp Op) {
    heavy::SourceLocation CallLoc = getSourceLocation(Op.getLoc());
    llvm::SmallVector<heavy::Value*, 8> ArgResults;
    LoadArgResults(Op, ArgResults);
    heavy::Value* Callee = ArgResults[0];

    // Now that we have ArgResults, we can pop the frame
    // before any tail call
    if (Op.isTailPos()) {
      pop_frame();
    }

    switch (Callee->getKind()) {
      case Value::Kind::Lambda:
        llvm_unreachable("TODO");
        break;
      case Value::Kind::LambdaIr: {
        LambdaIr* L = cast<LambdaIr>(Callee);
        return CallLambdaIr(Op, L, ArgResults);
      }
      case Value::Kind::Builtin: {
        Builtin* B = cast<Builtin>(Callee);
        heavy::Value* Result = B->Fn(Context, ArgResults);
        if (isa<Error>(Result)) return BlockItrTy();
        setValue(Op.result(), Result);
        return next(Op);
      }
      default: {
        String* Msg = Context.CreateString(
          "invalid operator for call expression: ",
          Callee->getKindName()
        );
        return SetError(CallLoc, Msg, Callee);
      }
    }
  }

  BlockItrTy Visit(BindingOp Op) {
    // create a Binding
    heavy::Value* V = getValue(Op.input());
    heavy::Binding* B = Context.CreateBinding(V);
    setValue(Op.result(), B);
    return next(Op);
  }

  BlockItrTy Visit(BuiltinOp Op) {
    heavy::Value* V = Op.builtinFn(); 
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(ContOp Op) {
    // This is the end of the road for the current block.
    // Get the op after the one in the current frame
    // and then pop the frame
    mlir::Operation* Caller = Context.EvalStack.top()->getOp();
    auto ContArgs = Op.args();
    auto Results = Caller->getResults();
    assert((Results.empty() ||
           Results.size() == ContArgs.size()) &&
        "continuation arity must match");
    for (unsigned i = 0; i < Results.size(); ++i) {
      setValue(Results[i], getValue(ContArgs[i])); 
    }

    // if this isn't receiving a tail call
    // then pop the frame
    // OR we can check that Caller is ... oh wait
    if (!ContArgs[0].getDefiningOp<ApplyOp>()) {
      pop_frame();
    }
    return next(Caller);
  }

  BlockItrTy Visit(LambdaOp Op) {
    heavy::Value* V = Context.CreateLambdaIr(Op, llvm::None);
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(LiteralOp Op) {
    // Map the IR value node to the run-time value
    heavy::Value* V = Op.input(); 
    setValue(Op.result(), V);
    return next(Op);
  }

  BlockItrTy Visit(SetOp Op) {
    BindingOp BVal = cast<BindingOp>(Op.binding().getDefiningOp());
    heavy::Binding* B = cast<heavy::Binding>(getValue(BVal,
                                             /*UnwrapBinding=*/false));
    heavy::Value* RHS = getValue(Op.input());
    B->setValue(RHS);
    return next(Op);
  }

#if 0 // hopefully won't need this GetTail stuff anymore
  mlir::Operation* GetTail(mlir::Block& Body) {
    assert(!Body.empty() && "body must have at least one operation");
    auto TailItr = --Body.end();
    // For cases where the ContOp takes a single result
    // (that isn't one of bindings)
    // return that Operation as the tail
    ContOp C = dyn_cast<ContOp>(&*TailItr);
    if (!C || C.args().size() > 1) return &*TailItr;

    mlir::Operation* D = C.args().front().getDefiningOp();
    return isa<BindingOp>(D) ? C : D;
  }

  mlir::Operation* VisitBodyUntilTail(mlir::Block& Body) {
    assert(!Body.empty() && "body must have at least one operation");
    mlir::Operation* Tail = GetTail(Body);
    auto TailItr = mlir::Block::iterator(*Tail);
    for (auto itr = Body.begin(); itr != TailItr; ++itr) {
      Visit(&*itr);
    }
    return VisitUntilTail(Tail);
  }

  mlir::Operation* VisitUntilTail(mlir::Operation* Op) {
    // TODO operations like IfOp may contain tail calls
    return Op;
  }
#endif

#if 0
  // TODO 
  // Visit operations having tail positions within them
  // IfOp, CondOp, SequenceOp
        
  mlir::Operation* VisitUntilTail(IfOp Op) {
    // TODO
  }
#endif
};

heavy::Value* opEval(OpEval& E) {
  return E.Impl->Run();
}

OpEval::OpEval(heavy::Context& C)
  : Impl(std::make_unique<OpEvalImpl>(C))
{ }

OpEval::~OpEval() = default;

}

#endif
